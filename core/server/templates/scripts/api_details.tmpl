{{define "api_details_js"}}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // =============================================================================
    // API STATE MANAGEMENT
    // =============================================================================

    const APIState = {
        openApiSchema: null,
        apiStats: null,
        apiComponents: null,
        allEndpoints: [],
        filteredEndpoints: [],
        availableVersions: [],
        currentVersion: null,

        reset() {
            this.openApiSchema = null;
            this.apiStats = null;
            this.apiComponents = null;
            this.allEndpoints = [];
            this.filteredEndpoints = [];
        },

        setEndpoints(endpoints) {
            this.allEndpoints = this.validateEndpoints(endpoints);
            this.filteredEndpoints = [...this.allEndpoints];
        },

        validateEndpoints(endpoints) {
            if (!Array.isArray(endpoints)) {
                console.warn('Expected endpoints array, got:', typeof endpoints, endpoints);
                return [];
            }

            return endpoints.map((endpoint, index) => {
                const validated = {
                    method: endpoint.method || 'GET',
                    path: endpoint.path || '/',
                    handler_name: endpoint.handler_name || `endpoint_${index}`,
                    description: endpoint.description || 'No description available',
                    tags: Array.isArray(endpoint.tags) ? endpoint.tags : [],
                    auth: this.validateAuthInfo(endpoint.auth),
                    request: endpoint.request || null,
                    response: endpoint.response || null
                };

                // Log validation warnings for debugging AST issues
                if (!endpoint.path) {
                    console.warn(`Endpoint ${index}: Missing path, using default`);
                }
                if (!endpoint.method) {
                    console.warn(`Endpoint ${index}: Missing method, using GET`);
                }

                return validated;
            });
        },

        validateAuthInfo(auth) {
            if (!auth) return { required: false };

            return {
                required: Boolean(auth.required),
                type: auth.type || 'unknown',
                description: auth.description || 'Authentication required',
                icon: auth.icon || 'üîê',
                collections: Array.isArray(auth.collections) ? auth.collections : [],
                owner_param: auth.owner_param || null
            };
        }
    };

    // =============================================================================
    // ERROR HANDLING UTILITIES
    // =============================================================================

    const ErrorHandler = {
        showError(message, details = null) {
            console.error('API Documentation Error:', message, details);

            this.updateContainerWithError('endpoints-list', message);
            this.updateContainerWithError('raw-schema-content', message, true);
            this.updateContainerWithError('components-content', message, true);

            StatusManager.updateStatus('error', 'Failed to load');
        },

        updateContainerWithError(containerId, message, isCodeBlock = false) {
            const container = document.getElementById(containerId);
            if (!container) return;

            if (isCodeBlock) {
                container.textContent = `Error: ${message}\n\nThis usually indicates:\n- Network connectivity issues\n- Server startup in progress\n- API endpoint not available`;
            } else {
                container.innerHTML = `
                    <div class="txt-center txt-danger p-4">
                        <i class="ri-error-warning-line ri-2x mb-2"></i>
                        <h4>Failed to Load API Documentation</h4>
                        <p class="txt-sm">${this.escapeHtml(message)}</p>
                        <div class="mt-3">
                            <button onclick="location.reload()" class="btn btn-sm btn-outline">
                                <i class="ri-refresh-line"></i> Retry
                            </button>
                        </div>
                    </div>
                `;
            }
        },

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        handleApiError(error, context = '') {
            let message = `${context}: ${error.message}`;

            if (error.message.includes('HTTP 404')) {
                message = 'API documentation endpoint not found. The server might still be starting up.';
            } else if (error.message.includes('Failed to fetch')) {
                message = 'Network error. Please check your connection and try again.';
            } else if (error.message.includes('JSON')) {
                message = 'Invalid response format. The API might be returning unexpected data.';
            }

            this.showError(message, error);
        }
    };

    // =============================================================================
    // STATUS MANAGEMENT
    // =============================================================================

    const StatusManager = {
        updateStatus(type, message) {
            const statusBadge = document.getElementById('api-status-badge');
            if (!statusBadge) return;

            statusBadge.textContent = message;
            statusBadge.className = `badge badge-sm ${this.getStatusClass(type)}`;
        },

        getStatusClass(type) {
            const classes = {
                'success': 'badge-success',
                'error': 'badge-danger',
                'loading': 'badge-warning',
                'warning': 'badge-warning'
            };
            return classes[type] || 'badge-secondary';
        },

        updateVersionBadge() {
            if (!APIState.currentVersion || !APIState.availableVersions) return;

            const versionInfo = APIState.availableVersions.find(v => v.version === APIState.currentVersion);
            if (!versionInfo) return;

            const status = versionInfo.status || 'stable';
            this.updateStatus(status.toLowerCase(), status);
        }
    };

    // =============================================================================
    // SCHEMA PROCESSING UTILITIES
    // =============================================================================

    const SchemaProcessor = {
        syntaxHighlight(data) {
            if (!data) return 'No data available';

            let json;
            try {
                json = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            } catch (error) {
                console.warn('Failed to stringify data for highlighting:', error);
                return String(data);
            }

            // Escape HTML and apply syntax highlighting
            return json
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
                    (match) => {
                        let cls = 'number';
                        if (/^"/.test(match)) {
                            cls = /:$/.test(match) ? 'key' : 'string';
                        } else if (/true|false/.test(match)) {
                            cls = 'boolean';
                        } else if (/null/.test(match)) {
                            cls = 'null';
                        }
                        return `<span class="json-${cls}">${match}</span>`;
                    });
        },

        jsonToYaml(obj, indent = 0) {
            if (!obj) return 'No data available';

            const spaces = '  '.repeat(indent);
            let yaml = '';

            try {
                for (const [key, value] of Object.entries(obj)) {
                    if (value === null) {
                        yaml += `${spaces}${key}: null\n`;
                    } else if (typeof value === 'object' && !Array.isArray(value)) {
                        yaml += `${spaces}${key}:\n${this.jsonToYaml(value, indent + 1)}`;
                    } else if (Array.isArray(value)) {
                        yaml += `${spaces}${key}:\n`;
                        value.forEach(item => {
                            if (typeof item === 'object') {
                                yaml += `${spaces}  -\n${this.jsonToYaml(item, indent + 2)}`;
                            } else {
                                yaml += `${spaces}  - ${item}\n`;
                            }
                        });
                    } else {
                        yaml += `${spaces}${key}: ${JSON.stringify(value)}\n`;
                    }
                }
            } catch (error) {
                console.error('YAML conversion error:', error);
                return 'Error converting to YAML format';
            }

            return yaml;
        },

        calculateStats(endpoints) {
            const stats = {
                total_endpoints: endpoints.length,
                methods: {},
                auth_types: {},
                tags: {},
                unique_paths: new Set(),
                auth_required_count: 0
            };

            endpoints.forEach(endpoint => {
                // Count methods
                const method = endpoint.method.toUpperCase();
                stats.methods[method] = (stats.methods[method] || 0) + 1;

                // Count auth types
                if (endpoint.auth?.required) {
                    stats.auth_required_count++;
                    const authType = endpoint.auth.type || 'unknown';
                    stats.auth_types[authType] = (stats.auth_types[authType] || 0) + 1;
                } else {
                    stats.auth_types['none'] = (stats.auth_types['none'] || 0) + 1;
                }

                // Count tags and paths
                endpoint.tags?.forEach(tag => {
                    stats.tags[tag] = (stats.tags[tag] || 0) + 1;
                });
                stats.unique_paths.add(endpoint.path);
            });

            stats.unique_paths_count = stats.unique_paths.size;
            stats.total_tags = Object.keys(stats.tags).length;

            return stats;
        }
    };

    // =============================================================================
    // UI CONTROLLERS
    // =============================================================================

    const TabController = {
        init() {
            document.querySelectorAll('#api-tabs .tab-item').forEach(button => {
                button.addEventListener('click', (e) => this.switchTab(e.target));
            });
        },

        switchTab(button) {
            const tabName = button.getAttribute('data-tab');

            // Update button states
            document.querySelectorAll('#api-tabs .tab-item').forEach(btn =>
                btn.classList.remove('active'));
            button.classList.add('active');

            // Update content visibility
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });

            const targetContent = document.getElementById(`${tabName}-tab`);
            if (targetContent) {
                targetContent.classList.add('active');
                targetContent.style.display = 'block';
            }
        }
    };

    const FilterController = {
        init() {
            const searchInput = document.getElementById('search-input');
            const methodFilter = document.getElementById('method-filter');
            const authFilter = document.getElementById('auth-filter');
            const tagFilter = document.getElementById('tag-filter');
            const clearBtn = document.getElementById('clear-filters-btn');

            if (searchInput) {
                searchInput.addEventListener('input', this.debounce(() => this.applyFilters(), 300));
            }

            [methodFilter, authFilter, tagFilter].forEach(filter => {
                if (filter) {
                    filter.addEventListener('change', () => this.applyFilters());
                }
            });

            if (clearBtn) {
                clearBtn.addEventListener('click', () => this.clearFilters());
            }
        },

        applyFilters() {
            const searchTerm = document.getElementById('search-input')?.value.toLowerCase() || '';
            const methodValue = document.getElementById('method-filter')?.value || '';
            const authValue = document.getElementById('auth-filter')?.value || '';
            const tagValue = document.getElementById('tag-filter')?.value || '';

            APIState.filteredEndpoints = APIState.allEndpoints.filter(endpoint => {
                const matchesSearch = !searchTerm || this.matchesSearchTerm(endpoint, searchTerm);
                const matchesMethod = !methodValue || endpoint.method.toLowerCase() === methodValue.toLowerCase();
                const matchesAuth = this.matchesAuth(endpoint, authValue);
                const matchesTag = !tagValue || endpoint.tags?.includes(tagValue);

                return matchesSearch && matchesMethod && matchesAuth && matchesTag;
            });

            EndpointRenderer.render();
            this.updateFilterSummary();
            this.updateActiveFilters();
        },

        matchesSearchTerm(endpoint, term) {
            const searchableFields = [
                endpoint.path,
                endpoint.description,
                endpoint.handler_name,
                ...(endpoint.tags || [])
            ];

            return searchableFields.some(field =>
                field?.toLowerCase().includes(term));
        },

        matchesAuth(endpoint, authValue) {
            if (!authValue) return true;

            if (authValue === 'required') return endpoint.auth?.required;
            if (authValue === 'none') return !endpoint.auth?.required;

            return endpoint.auth?.type === authValue;
        },

        clearFilters() {
            ['search-input', 'method-filter', 'auth-filter', 'tag-filter'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = '';
            });

            APIState.filteredEndpoints = [...APIState.allEndpoints];
            EndpointRenderer.render();
            this.updateFilterSummary();
            this.updateActiveFilters();
        },

        updateFilterSummary() {
            const filteredCountSpan = document.getElementById('filtered-count');
            const totalCountSpan = document.getElementById('total-count');
            const summaryDiv = document.getElementById('results-summary');

            if (filteredCountSpan) filteredCountSpan.textContent = APIState.filteredEndpoints.length;
            if (totalCountSpan) totalCountSpan.textContent = APIState.allEndpoints.length;
            if (summaryDiv) summaryDiv.style.display = APIState.allEndpoints.length > 0 ? 'block' : 'none';
        },

        updateActiveFilters() {
            const activeFiltersDiv = document.getElementById('active-filters');
            const filterTagsDiv = document.getElementById('filter-tags');

            if (!activeFiltersDiv || !filterTagsDiv) return;

            const filters = [];
            const searchValue = document.getElementById('search-input')?.value;
            const methodValue = document.getElementById('method-filter')?.value;
            const authValue = document.getElementById('auth-filter')?.value;
            const tagValue = document.getElementById('tag-filter')?.value;

            if (searchValue) filters.push({ type: 'search', value: searchValue, label: `Search: "${searchValue}"` });
            if (methodValue) filters.push({ type: 'method', value: methodValue, label: `Method: ${methodValue.toUpperCase()}` });
            if (authValue) filters.push({ type: 'auth', value: authValue, label: `Auth: ${authValue.replace(/_/g, ' ')}` });
            if (tagValue) filters.push({ type: 'tag', value: tagValue, label: `Tag: ${tagValue}` });

            if (filters.length > 0) {
                activeFiltersDiv.style.display = 'block';
                filterTagsDiv.innerHTML = filters.map(filter => `
                    <span class="badge badge-sm badge-secondary">
                        ${filter.label}
                        <i class="ri-close-line cursor-pointer ml-1" onclick="FilterController.clearFilter('${filter.type}')"></i>
                    </span>
                `).join('');
            } else {
                activeFiltersDiv.style.display = 'none';
            }
        },

        clearFilter(type) {
            const elementId = {
                'search': 'search-input',
                'method': 'method-filter',
                'auth': 'auth-filter',
                'tag': 'tag-filter'
            }[type];

            if (elementId) {
                const element = document.getElementById(elementId);
                if (element) element.value = '';
                this.applyFilters();
            }
        },

        populateFilterOptions(stats) {
            this.populateMethodOptions(stats.methods);
            this.populateAuthOptions(stats.auth_types);
            this.populateTagOptions(stats.tags);
        },

        populateMethodOptions(methods) {
            const select = document.getElementById('method-filter');
            if (!select) return;

            // Clear existing options except first
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            Object.keys(methods).forEach(method => {
                const option = document.createElement('option');
                option.value = method.toLowerCase();
                option.textContent = `${method} (${methods[method]})`;
                select.appendChild(option);
            });
        },

        populateAuthOptions(authTypes) {
            const select = document.getElementById('auth-filter');
            if (!select) return;

            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            const authLabels = {
                'none': 'No Auth Required',
                'required': 'Auth Required',
                'superuser': 'Superuser Only',
                'user': 'User Auth',
                'guest_only': 'Guest Only'
            };

            Object.keys(authTypes).forEach(authType => {
                const option = document.createElement('option');
                option.value = authType;
                option.textContent = `${authLabels[authType] || authType} (${authTypes[authType]})`;
                select.appendChild(option);
            });
        },

        populateTagOptions(tags) {
            const select = document.getElementById('tag-filter');
            if (!select || !Object.keys(tags).length) return;

            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            Object.keys(tags).forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = `${tag} (${tags[tag]})`;
                select.appendChild(option);
            });
        },

        debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    };

    const EndpointRenderer = {
        render() {
            const container = document.getElementById('endpoints-list');
            if (!container) return;

            if (!APIState.filteredEndpoints || APIState.filteredEndpoints.length === 0) {
                this.renderEmpty(container);
                return;
            }

            const html = APIState.filteredEndpoints.map(endpoint => this.renderEndpoint(endpoint)).join('');
            container.innerHTML = html;

            this.attachEventListeners(container);
        },

        renderEmpty(container) {
            const message = APIState.allEndpoints.length === 0
                ? 'No API endpoints discovered yet'
                : 'No endpoints match your current filters';

            container.innerHTML = `
                <div class="txt-center txt-hint p-4">
                    <i class="ri-route-line ri-2x mb-2"></i>
                    <h4>${message}</h4>
                    ${APIState.allEndpoints.length > 0 ? `
                        <button onclick="window.FilterController.clearFilters()" class="btn btn-sm btn-outline mt-2">
                            <i class="ri-close-line"></i> Clear Filters
                        </button>
                    ` : ''}
                </div>
            `;
        },

        renderEndpoint(endpoint) {
            const method = endpoint.method.toLowerCase();
            const operationId = endpoint.handler_name.replace(/[^a-zA-Z0-9]/g, '_');
            const authRequired = endpoint.auth?.required;

            return `
                <div class="api-endpoint">
                    <div class="api-endpoint-header" onclick="this.parentElement.querySelector('.api-endpoint-content').classList.toggle('active')">
                        <span class="http-method ${method}">${method.toUpperCase()}</span>
                        <span class="flex-fill txt-mono">${endpoint.path}</span>
                        <span class="txt-sm txt-hint">${endpoint.description}</span>
                        ${authRequired ? `<span class="auth-icon" title="${endpoint.auth.description}">${endpoint.auth.icon}</span>` : ''}
                        <i class="ri-external-link-line external-link-icon" title="Test endpoint" onclick="event.stopPropagation(); APITester.testEndpoint('${method}', '${endpoint.path}', ${authRequired})"></i>
                        <i class="ri-arrow-down-s-line"></i>
                    </div>
                    <div class="api-endpoint-content">
                        ${this.renderEndpointDetails(endpoint, operationId)}
                    </div>
                </div>
            `;
        },

        renderEndpointDetails(endpoint, operationId) {
            return `
                <div class="mb-2">
                    <strong>Description:</strong>
                    <p class="txt-sm txt-hint mt-1">${endpoint.description}</p>
                </div>

                ${this.renderAuthSection(endpoint.auth)}

                ${endpoint.tags?.length ? `
                    <div class="mb-2">
                        <strong>Tags:</strong>
                        <div class="flex gap-1 mt-1">
                            ${endpoint.tags.map(tag => `<span class="badge badge-sm">${tag}</span>`).join('')}
                        </div>
                    </div>
                ` : ''}

                ${this.renderSchemaSection('Request', endpoint.request, `request-${operationId}`)}
                ${this.renderSchemaSection('Response', endpoint.response, `response-${operationId}`)}
            `;
        },

        renderAuthSection(auth) {
            if (!auth?.required) {
                return `
                    <div class="mb-2">
                        <strong>Authentication:</strong>
                        <div class="auth-details auth-none mt-1">
                            <div class="flex align-center gap-2">
                                <span class="auth-icon-large">üåê</span>
                                <div>
                                    <div class="txt-sm txt-bold txt-success">No authentication required</div>
                                    <div class="auth-type">public access</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="mb-2">
                    <strong>Authentication:</strong>
                    <div class="auth-details mt-1">
                        <div class="flex align-center gap-2 mb-2">
                            <span class="auth-icon-large auth-${auth.type}">${auth.icon}</span>
                            <div class="flex-fill">
                                <div class="txt-sm txt-bold">${auth.description}</div>
                                <div class="auth-type">${auth.type.replace(/_/g, ' ')}</div>
                            </div>
                        </div>
                        ${auth.collections?.length ? `
                            <div class="auth-param">
                                <strong>Required Collections:</strong>
                                ${auth.collections.map(c => `<code class="auth-collection">${c}</code>`).join(', ')}
                            </div>
                        ` : ''}
                        ${auth.owner_param ? `
                            <div class="auth-param">
                                <strong>Owner Parameter:</strong> <code class="auth-param-code">${auth.owner_param}</code>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        },

        renderSchemaSection(title, schema, id) {
            if (!schema) return '';

            return `
                <div class="mb-2">
                    <div class="flex justify-between align-center mb-1">
                        <strong>${title} Schema:</strong>
                        <button class="btn btn-xs btn-secondary copy-schema-btn" data-copy-target="${id}">
                            <i class="ri-file-copy-line"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block mt-1"><code id="${id}">${SchemaProcessor.syntaxHighlight(schema)}</code></pre>
                </div>
            `;
        },

        attachEventListeners(container) {
            container.querySelectorAll('.copy-schema-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.copySchemaToClipboard(button);
                });
            });
        },

        copySchemaToClipboard(button) {
            const targetId = button.getAttribute('data-copy-target');
            const targetElement = document.getElementById(targetId);
            if (!targetElement) return;

            const content = targetElement.textContent || targetElement.innerText;
            navigator.clipboard.writeText(content).then(() => {
                const originalHtml = button.innerHTML;
                button.innerHTML = '<i class="ri-check-line"></i> Copied!';
                button.classList.add('btn-success');
                button.classList.remove('btn-secondary');

                setTimeout(() => {
                    button.innerHTML = originalHtml;
                    button.classList.remove('btn-success');
                    button.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy schema:', err);
                button.innerHTML = '<i class="ri-close-line"></i> Failed';
                button.classList.add('btn-danger');
                button.classList.remove('btn-secondary');

                setTimeout(() => {
                    button.innerHTML = '<i class="ri-file-copy-line"></i> Copy';
                    button.classList.remove('btn-danger');
                    button.classList.add('btn-secondary');
                }, 2000);
            });
        }
    };

    // Expose FilterController globally so it can be called from HTML templates
    window.FilterController = FilterController;

    const APITester = {
        testEndpoint(method, path, authRequired) {
            // Simple endpoint tester - opens in new tab for GET, shows modal for others
            if (method.toUpperCase() === 'GET' && !authRequired) {
                window.open(window.location.origin + path, '_blank');
                return;
            }

            // For more complex endpoints, could implement a modal here
            alert(`Testing ${method.toUpperCase()} ${path}\n\nThis would typically open a request builder interface.`);
        }
    };

    // =============================================================================
    // DATA LOADING AND INITIALIZATION
    // =============================================================================

    const APILoader = {
        async loadVersions() {
            try {
                StatusManager.updateStatus('loading', 'Loading versions...');
                console.log('Loading API versions...');

                const response = await fetch('/api/docs/versions');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Versions data received:', data);

                APIState.availableVersions = data.versions || [];
                APIState.currentVersion = data.default_version || (APIState.availableVersions.length > 0 ? APIState.availableVersions[0].version : null);

                console.log('Available versions:', APIState.availableVersions);
                console.log('Current version:', APIState.currentVersion);

                this.populateVersionSelector();

                // Load the current version
                if (APIState.currentVersion && APIState.availableVersions.length > 0) {
                    await this.loadSchema();
                } else {
                    throw new Error('No API versions available');
                }

            } catch (error) {
                console.error('Failed to load versions:', error);
                ErrorHandler.handleApiError(error, 'Failed to load API versions');

                // Update version selector to show error state
                const selector = document.getElementById('version-selector');
                if (selector) {
                    selector.innerHTML = '<option value="">Error loading versions</option>';
                }
            }
        },

        async loadSchema() {
            if (!APIState.currentVersion) {
                throw new Error('No API version selected');
            }

            try {
                StatusManager.updateStatus('loading', 'Loading schema...');

                const url = `/api/docs/${APIState.currentVersion}`;
                console.log('Loading OpenAPI schema from:', url);

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const schemaData = await response.json();
                console.log('Schema data received:', schemaData);

                // Validate and process the schema
                this.processSchema(schemaData);

                StatusManager.updateStatus('success', 'Loaded');
                StatusManager.updateVersionBadge();

                // Update UI
                this.populateOverview();
                this.updateRawContent();
                this.showFilters();

            } catch (error) {
                ErrorHandler.handleApiError(error, 'Failed to load API schema');
                throw error;
            }
        },

        processSchema(schemaData) {
            // Reset state
            APIState.reset();

            // Store schema
            APIState.openApiSchema = schemaData;

            // Extract and validate endpoints
            const endpoints = schemaData.endpoints || [];
            APIState.setEndpoints(endpoints);

            console.log('Processed endpoints:', APIState.allEndpoints.length);

            // Extract components
            APIState.apiComponents = schemaData.components || {};
            console.log('Loaded components:', Object.keys(APIState.apiComponents));

            // Calculate statistics
            APIState.apiStats = SchemaProcessor.calculateStats(APIState.allEndpoints);

            // Update UI components
            this.updateStats();
            FilterController.populateFilterOptions(APIState.apiStats);
            EndpointRenderer.render();
            FilterController.updateFilterSummary();
        },

        populateVersionSelector() {
            const selector = document.getElementById('version-selector');
            if (!selector) return;

            selector.innerHTML = APIState.availableVersions.map(version => {
                const statusBadge = version.status ? ` [${version.status}]` : '';
                const title = version.config?.title || version.version;
                const semanticVersion = version.config?.version || 'unknown';
                const displayText = `${title} (${semanticVersion})${statusBadge}`;
                const isDefault = version.version === APIState.currentVersion ? ' - default' : '';

                return `<option value="${version.version}" ${version.version === APIState.currentVersion ? 'selected' : ''}>
                    ${displayText}${isDefault}
                </option>`;
            }).join('');

            // Remove any existing event listeners by cloning the element
            const newSelector = selector.cloneNode(true);
            selector.parentNode.replaceChild(newSelector, selector);

            newSelector.addEventListener('change', async (e) => {
                if (e.target.value && e.target.value !== APIState.currentVersion) {
                    APIState.currentVersion = e.target.value;
                    console.log('Version changed to:', APIState.currentVersion);

                    // Clear filters when version changes
                    FilterController.clearFilters();

                    try {
                        await this.loadSchema();
                    } catch (error) {
                        console.error('Failed to load schema for version:', APIState.currentVersion, error);
                        ErrorHandler.handleApiError(error, `Failed to load schema for version ${APIState.currentVersion}`);
                    }
                }
            });
        },

        populateOverview() {
            const schema = APIState.openApiSchema;
            if (!schema) return;

            // Update title and description
            const title = document.getElementById('api-title');
            const headerTitle = document.getElementById('api-header-title');
            const description = document.getElementById('api-description');

            if (title) title.textContent = schema.title || 'API Documentation';
            if (headerTitle) headerTitle.textContent = schema.title || 'API Documentation';
            if (description) description.textContent = schema.description || 'No description available';

            // Show overview section
            const overview = document.getElementById('api-overview');
            if (overview) overview.style.display = 'block';
        },

        updateStats() {
            if (!APIState.apiStats) return;

            const stats = APIState.apiStats;

            // Update endpoint count
            const endpointCount = document.getElementById('api-endpoints-count');
            if (endpointCount) endpointCount.textContent = stats.total_endpoints;

            // Update detailed stats if elements exist
            const authRequired = document.getElementById('stats-auth-required');
            const uniquePaths = document.getElementById('stats-unique-paths');
            const totalTags = document.getElementById('stats-total-tags');

            if (authRequired) authRequired.textContent = stats.auth_required_count;
            if (uniquePaths) uniquePaths.textContent = stats.unique_paths_count;
            if (totalTags) totalTags.textContent = stats.total_tags || 0;
        },

        updateRawContent() {
            this.updateRawSchema('json');
            this.updateComponents('json');
        },

        updateRawSchema(format) {
            const content = document.getElementById('raw-schema-content');
            if (!content || !APIState.openApiSchema) return;

            try {
                if (format === 'yaml') {
                    content.textContent = SchemaProcessor.jsonToYaml(APIState.openApiSchema);
                } else {
                    content.innerHTML = SchemaProcessor.syntaxHighlight(APIState.openApiSchema);
                }
            } catch (error) {
                content.textContent = `Error formatting schema: ${error.message}`;
            }
        },

        updateComponents(format) {
            const content = document.getElementById('components-content');
            if (!content) return;

            const components = APIState.apiComponents || {};

            try {
                if (format === 'yaml') {
                    content.textContent = SchemaProcessor.jsonToYaml(components);
                } else {
                    content.innerHTML = SchemaProcessor.syntaxHighlight(components);
                }
            } catch (error) {
                content.textContent = `Error formatting components: ${error.message}`;
            }
        },

        showFilters() {
            const filtersDiv = document.getElementById('api-filters');
            if (filtersDiv) filtersDiv.style.display = 'block';
        }
    };

    // =============================================================================
    // FORMAT SWITCHING CONTROLLERS
    // =============================================================================

    const FormatController = {
        init() {
            this.initSchemaFormatSwitchers();
            this.initComponentsFormatSwitchers();
            this.initCopyButtons();
        },

        initSchemaFormatSwitchers() {
            const jsonBtn = document.getElementById('json-format-btn');
            const yamlBtn = document.getElementById('yaml-format-btn');

            if (jsonBtn && yamlBtn) {
                jsonBtn.addEventListener('click', () => {
                    this.updateFormatButtons(jsonBtn, yamlBtn);
                    APILoader.updateRawSchema('json');
                });

                yamlBtn.addEventListener('click', () => {
                    this.updateFormatButtons(yamlBtn, jsonBtn);
                    APILoader.updateRawSchema('yaml');
                });
            }
        },

        initComponentsFormatSwitchers() {
            const jsonBtn = document.getElementById('components-json-format-btn');
            const yamlBtn = document.getElementById('components-yaml-format-btn');

            if (jsonBtn && yamlBtn) {
                jsonBtn.addEventListener('click', () => {
                    this.updateFormatButtons(jsonBtn, yamlBtn);
                    APILoader.updateComponents('json');
                });

                yamlBtn.addEventListener('click', () => {
                    this.updateFormatButtons(yamlBtn, jsonBtn);
                    APILoader.updateComponents('yaml');
                });
            }
        },

        updateFormatButtons(activeBtn, inactiveBtn) {
            activeBtn.classList.add('active');
            inactiveBtn.classList.remove('active');
        },

        initCopyButtons() {
            this.initCopyButton('copy-schema-btn', 'raw-schema-content');
            this.initCopyButton('copy-components-btn', 'components-content');
        },

        initCopyButton(buttonId, contentId) {
            const button = document.getElementById(buttonId);
            if (!button) return;

            button.addEventListener('click', () => {
                const content = document.getElementById(contentId);
                if (!content) return;

                const text = content.textContent || content.innerText;
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = button.innerHTML;
                    button.innerHTML = '<i class="ri-check-line"></i> Copied!';
                    button.classList.add('btn-success');
                    button.classList.remove('btn-secondary');

                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.classList.remove('btn-success');
                        button.classList.add('btn-secondary');
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    const originalText = button.innerHTML;
                    button.innerHTML = '<i class="ri-close-line"></i> Failed';
                    button.classList.add('btn-danger');
                    button.classList.remove('btn-secondary');

                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.classList.remove('btn-danger');
                        button.classList.add('btn-secondary');
                    }, 2000);
                });
            });
        }
    };



    // =============================================================================
    // APPLICATION INITIALIZATION
    // =============================================================================

    async function initializeApp() {
        console.log('Initializing API Documentation System...');

        try {
            // Initialize UI controllers
            TabController.init();
            FilterController.init();
            FormatController.init();

            // Load API data
            await APILoader.loadVersions();

            console.log('API Documentation System initialized successfully');
        } catch (error) {
            console.error('Failed to initialize API Documentation System:', error);
            ErrorHandler.showError('Failed to initialize the documentation system. Please refresh the page to try again.');
        }
    }

    // Start the application
    initializeApp();


});
</script>
{{end}}
