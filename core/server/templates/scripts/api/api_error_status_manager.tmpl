{{define "api_error_status_manager_js"}}
    // =============================================================================
    // ERROR HANDLING AND STATUS MANAGEMENT - CONSOLIDATED
    // =============================================================================

    const ErrorStatusManager = {
        // Error types
        ErrorTypes: {
            VALIDATION: 'validation',
            NETWORK: 'network',
            API: 'api',
            SYSTEM: 'system',
            USER: 'user'
        },

        // Status types
        StatusTypes: {
            SUCCESS: 'success',
            ERROR: 'error',
            LOADING: 'loading',
            WARNING: 'warning',
            INFO: 'info'
        },

        // Internal state
        _currentStatus: null,
        _errorHistory: [],
        _maxErrorHistory: 50,
        _statusElement: null,
        _initialized: false,

        // Initialize the manager
        init() {
            if (this._initialized) return;

            console.log('Initializing Error Status Manager...');

            try {
                this._statusElement = document.getElementById('api-status-badge');
                this._initialized = true;

                // Set initial status
                this.updateStatus(this.StatusTypes.INFO, 'System initializing...');

                console.log('Error Status Manager initialized successfully');
            } catch (error) {
                console.error('Failed to initialize Error Status Manager:', error);
                this._initialized = false;
            }
        },

        // =============================================================================
        // STATUS MANAGEMENT
        // =============================================================================

        // Update system status
        updateStatus(type, message, details = {}) {
            try {
                if (!this._initialized) {
                    this.init();
                }

                const statusInfo = {
                    type,
                    message,
                    details,
                    timestamp: new Date().toISOString()
                };

                this._currentStatus = statusInfo;
                this._updateStatusDisplay(statusInfo);

                console.log(`Status updated: [${type.toUpperCase()}] ${message}`);

                // Notify observers if available
                if (window.APIState && typeof APIState.addObserver === 'function') {
                    // Don't create observer here, just log for debugging
                    console.debug('Status update:', statusInfo);
                }

                return statusInfo;
            } catch (error) {
                console.error('Failed to update status:', error);
                return null;
            }
        },

        // Update status display element
        _updateStatusDisplay(statusInfo) {
            if (!this._statusElement) return;

            const { type, message } = statusInfo;

            this._statusElement.textContent = message;
            this._statusElement.className = `badge badge-sm ${this._getStatusClass(type)}`;

            // Add tooltip with timestamp if supported
            if (this._statusElement.setAttribute) {
                this._statusElement.setAttribute('title',
                    `${message}\nUpdated: ${new Date(statusInfo.timestamp).toLocaleTimeString()}`
                );
            }
        },

        // Get CSS class for status type
        _getStatusClass(type) {
            const classMap = {
                [this.StatusTypes.SUCCESS]: 'badge-success',
                [this.StatusTypes.ERROR]: 'badge-danger',
                [this.StatusTypes.LOADING]: 'badge-warning',
                [this.StatusTypes.WARNING]: 'badge-warning',
                [this.StatusTypes.INFO]: 'badge-info'
            };

            return classMap[type] || 'badge-secondary';
        },

        // Update version badge specifically
        updateVersionBadge() {
            if (!window.APIState) return;

            try {
                const { currentVersion, availableVersions } = APIState;
                if (!currentVersion || !availableVersions) return;

                const versionInfo = availableVersions.find(v => v.version === currentVersion);
                if (!versionInfo) return;

                const status = versionInfo.status || 'stable';
                this.updateStatus(status.toLowerCase(), status);
            } catch (error) {
                console.warn('Failed to update version badge:', error);
            }
        },

        // Get current status
        getCurrentStatus() {
            return this._currentStatus;
        },

        // Clear status
        clearStatus() {
            this.updateStatus(this.StatusTypes.INFO, 'Ready');
        },

        // =============================================================================
        // ERROR HANDLING
        // =============================================================================

        // Create standardized error object
        createError(type, message, details = {}) {
            const error = new Error(message);
            error.type = type;
            error.details = details;
            error.timestamp = new Date().toISOString();
            error.id = this._generateErrorId();
            return error;
        },

        // Handle errors consistently
        handleError(error, context = 'Unknown') {
            try {
                const errorInfo = {
                    id: error.id || this._generateErrorId(),
                    message: error.message || 'Unknown error',
                    type: error.type || this.ErrorTypes.SYSTEM,
                    context: context,
                    timestamp: error.timestamp || new Date().toISOString(),
                    details: error.details || {},
                    stack: error.stack
                };

                // Add to error history
                this._addToErrorHistory(errorInfo);

                // Log to console with context
                console.error(`[${context}] ${errorInfo.type.toUpperCase()}: ${errorInfo.message}`, errorInfo);

                // Update status with user-friendly message
                const userMessage = this._getUserFriendlyMessage(errorInfo);
                this.updateStatus(this.StatusTypes.ERROR, userMessage, errorInfo);

                // Show user notification for critical errors
                if (this._isCriticalError(errorInfo)) {
                    this._showCriticalErrorNotification(errorInfo);
                }

                return errorInfo;
            } catch (handlingError) {
                console.error('Error handling failed:', handlingError);
                this.updateStatus(this.StatusTypes.ERROR, 'System error occurred');
                return null;
            }
        },

        // Convert technical errors to user-friendly messages
        _getUserFriendlyMessage(errorInfo) {
            const { type, message, context } = errorInfo;

            // Context-specific messages
            if (context.includes('Network') || context.includes('API')) {
                if (message.includes('404')) return 'Resource not found';
                if (message.includes('500')) return 'Server error occurred';
                if (message.includes('timeout')) return 'Request timed out';
                if (message.includes('Failed to fetch')) return 'Network connection failed';
            }

            // Type-specific messages
            switch (type) {
                case this.ErrorTypes.NETWORK:
                    return 'Network connection failed. Please check your internet connection.';
                case this.ErrorTypes.API:
                    return message.includes('404') ? 'API endpoint not found' :
                           message.includes('500') ? 'Server error occurred' :
                           'API request failed';
                case this.ErrorTypes.VALIDATION:
                    return `Invalid input: ${message}`;
                case this.ErrorTypes.USER:
                    return message; // User errors are already friendly
                default:
                    return 'An unexpected error occurred';
            }
        },

        // Check if error is critical and needs immediate attention
        _isCriticalError(errorInfo) {
            const criticalKeywords = ['initialization', 'system', 'fatal', 'critical'];
            const criticalTypes = [this.ErrorTypes.SYSTEM];

            return criticalTypes.includes(errorInfo.type) ||
                   criticalKeywords.some(keyword =>
                       errorInfo.message.toLowerCase().includes(keyword) ||
                       errorInfo.context.toLowerCase().includes(keyword)
                   );
        },

        // Show critical error notification to user
        _showCriticalErrorNotification(errorInfo) {
            // Try to show in a modal or prominent place
            const container = document.getElementById('main-content') || document.body;

            const notification = document.createElement('div');
            notification.className = 'alert alert-danger alert-dismissible critical-error-notification';
            notification.innerHTML = `
                <div class="flex align-center justify-between">
                    <div class="flex align-center gap-2">
                        <i class="ri-error-warning-line ri-lg"></i>
                        <div>
                            <strong>Critical Error</strong>
                            <div class="txt-sm">${this._getUserFriendlyMessage(errorInfo)}</div>
                        </div>
                    </div>
                    <button type="button" class="btn btn-sm btn-danger" onclick="this.parentElement.parentElement.remove()">
                        <i class="ri-close-line"></i>
                    </button>
                </div>
            `;

            // Insert at the top of container
            container.insertBefore(notification, container.firstChild);

            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 10000);
        },

        // Add error to history
        _addToErrorHistory(errorInfo) {
            this._errorHistory.unshift(errorInfo);

            // Maintain history size limit
            if (this._errorHistory.length > this._maxErrorHistory) {
                this._errorHistory = this._errorHistory.slice(0, this._maxErrorHistory);
            }
        },

        // Generate unique error ID
        _generateErrorId() {
            return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        },

        // Wrap async functions with error handling
        wrapAsync(fn, context = 'AsyncOperation') {
            return async (...args) => {
                try {
                    return await fn(...args);
                } catch (error) {
                    this.handleError(error, context);
                    throw error;
                }
            };
        },

        // Retry mechanism with exponential backoff
        async retry(operation, maxAttempts = 3, baseDelay = 1000, context = 'RetryOperation') {
            let lastError;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    if (attempt > 1) {
                        this.updateStatus(this.StatusTypes.LOADING, `Retrying... (${attempt}/${maxAttempts})`);
                    }

                    return await operation();
                } catch (error) {
                    lastError = error;

                    if (attempt === maxAttempts) {
                        break;
                    }

                    const delay = baseDelay * Math.pow(2, attempt - 1);
                    console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms:`, error.message);

                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

            const finalError = this.createError(
                this.ErrorTypes.SYSTEM,
                `Operation failed after ${maxAttempts} attempts: ${lastError.message}`,
                { originalError: lastError, attempts: maxAttempts, context }
            );

            this.handleError(finalError, context);
            throw finalError;
        },

        // =============================================================================
        // UTILITY AND DEBUG METHODS
        // =============================================================================

        // Get error history
        getErrorHistory() {
            return [...this._errorHistory]; // Return copy
        },

        // Clear error history
        clearErrorHistory() {
            this._errorHistory = [];
            console.log('Error history cleared');
        },

        // Get system health based on recent errors
        getSystemHealth() {
            const recentErrors = this._errorHistory.filter(error => {
                const errorTime = new Date(error.timestamp).getTime();
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                return errorTime > fiveMinutesAgo;
            });

            const criticalErrors = recentErrors.filter(error => this._isCriticalError(error));

            let health = 'healthy';
            let score = 100;

            if (criticalErrors.length > 0) {
                health = 'critical';
                score = Math.max(0, 100 - (criticalErrors.length * 30));
            } else if (recentErrors.length > 5) {
                health = 'degraded';
                score = Math.max(20, 100 - (recentErrors.length * 10));
            } else if (recentErrors.length > 2) {
                health = 'warning';
                score = Math.max(50, 100 - (recentErrors.length * 15));
            }

            return {
                status: health,
                score,
                recentErrors: recentErrors.length,
                criticalErrors: criticalErrors.length,
                lastError: this._errorHistory[0] || null,
                timestamp: new Date().toISOString()
            };
        },

        // Get debug information
        getDebugInfo() {
            return {
                initialized: this._initialized,
                currentStatus: this._currentStatus,
                errorHistoryCount: this._errorHistory.length,
                systemHealth: this.getSystemHealth(),
                recentErrors: this._errorHistory.slice(0, 5).map(error => ({
                    id: error.id,
                    type: error.type,
                    message: error.message,
                    context: error.context,
                    timestamp: error.timestamp
                }))
            };
        },

        // Export error data for debugging
        exportErrorData() {
            return {
                currentStatus: this._currentStatus,
                errorHistory: this._errorHistory,
                systemHealth: this.getSystemHealth(),
                exportedAt: new Date().toISOString()
            };
        },

        // Import error data (for testing/debugging)
        importErrorData(data) {
            try {
                if (data.currentStatus) {
                    this._currentStatus = data.currentStatus;
                }

                if (Array.isArray(data.errorHistory)) {
                    this._errorHistory = data.errorHistory.slice(0, this._maxErrorHistory);
                }

                console.log('Error data imported successfully');
                return true;
            } catch (error) {
                console.error('Failed to import error data:', error);
                return false;
            }
        },

        // Reset everything
        reset() {
            this._currentStatus = null;
            this._errorHistory = [];
            this.clearStatus();
            console.log('Error Status Manager reset');
        },

        // Destroy and cleanup
        destroy() {
            this.reset();
            this._statusElement = null;
            this._initialized = false;
            console.log('Error Status Manager destroyed');
        }
    };

    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => ErrorStatusManager.init());
    } else {
        ErrorStatusManager.init();
    }

    // Make globally available (replaces ErrorHandler and StatusManager)
    window.ErrorStatusManager = ErrorStatusManager;
    window.StatusManager = ErrorStatusManager; // Backward compatibility
    window.ErrorHandler = ErrorStatusManager; // Backward compatibility
{{end}}
