{{define "api_request_handler_js"}}
    // =============================================================================
    // API REQUEST HANDLER - SIMPLIFIED FOR AST-BASED SCHEMAS
    // =============================================================================

    const APIRequestHandler = {

        // Send HTTP request using simplified form data
        async sendRequest(endpoint, authToken = null) {
            if (!endpoint) {
                console.error('No endpoint provided for request');
                return;
            }

            const sendBtn = document.getElementById('send-request-btn');
            const originalText = sendBtn ? sendBtn.innerHTML : '';

            try {
                // Update button state
                if (sendBtn) {
                    sendBtn.innerHTML = '<i class="ri-loader-4-line animate-spin"></i> Sending...';
                    sendBtn.disabled = true;
                }

                // Validate and collect form data
                const validation = APIFormBuilder.validateForm(endpoint);

                if (!validation.valid) {
                    throw new Error(`Form validation failed:\n${validation.errors.join('\n')}`);
                }

                const formData = validation.data;

                // Build request configuration
                const requestConfig = this.buildRequestConfig(endpoint, formData, authToken);

                // Execute request
                const response = await this.executeRequest(requestConfig);

                // Display response
                this.displayResponse(response, endpoint);

                // Switch to response tab
                if (typeof APITesterSidebar !== 'undefined' && APITesterSidebar.switchTab) {
                    APITesterSidebar.switchTab('response');
                }

                return response;

            } catch (error) {
                console.error('Request failed:', error);
                this.displayError(error, endpoint);

                if (typeof APITesterSidebar !== 'undefined' && APITesterSidebar.switchTab) {
                    APITesterSidebar.switchTab('response');
                }
            } finally {
                // Restore button state
                if (sendBtn) {
                    sendBtn.innerHTML = originalText;
                    sendBtn.disabled = false;
                }
            }
        },

        // Build request configuration from form data
        buildRequestConfig(endpoint, formData, authToken = null) {
            // Build URL with path parameters
            let url = endpoint.path;
            for (const [key, value] of Object.entries(formData.pathParameters)) {
                url = url.replace(`{${key}}`, encodeURIComponent(value));
            }

            // Add query parameters
            const queryParams = new URLSearchParams(formData.queryParameters);
            if (queryParams.toString()) {
                url += '?' + queryParams.toString();
            }

            // Build request configuration
            const config = {
                method: endpoint.method,
                url: url,
                headers: {
                    'Content-Type': 'application/json'
                }
            };

            // Add Authorization header if auth token is provided
            if (authToken) {
                config.headers['Authorization'] = `Bearer ${authToken}`;
                console.log('Added Authorization header to request');
            }

            // Add request body for methods that support it
            if (['POST', 'PUT', 'PATCH'].includes(endpoint.method) &&
                Object.keys(formData.requestBody).length > 0) {
                config.body = JSON.stringify(formData.requestBody);
            }

            return config;
        },

        // Execute HTTP request
        async executeRequest(config) {
            const startTime = performance.now();

            const response = await fetch(config.url, {
                method: config.method,
                headers: config.headers,
                body: config.body
            });

            const endTime = performance.now();
            const duration = Math.round(endTime - startTime);

            // Parse response body
            let responseData;
            const contentType = response.headers.get('content-type');

            if (contentType && contentType.includes('application/json')) {
                try {
                    responseData = await response.json();
                } catch (e) {
                    responseData = await response.text();
                }
            } else {
                responseData = await response.text();
            }

            return {
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers.entries()),
                data: responseData,
                duration: duration,
                url: config.url,
                method: config.method
            };
        },

        // Display successful response in sidebar
        displayResponse(response, endpoint) {
            // Update response status
            this.updateResponseStatus(response.status, response.statusText, response.duration);

            // Hide empty state, show response content
            const emptyState = document.getElementById('response-empty-state');
            const copyBtn = document.getElementById('copy-response-btn');
            if (emptyState) emptyState.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'block';

            // Update response body with proper formatting
            const responseBody = document.getElementById('response-body');
            if (responseBody) {
                responseBody.style.display = 'block';
                if (typeof SchemaProcessor !== 'undefined') {
                    const formatted = SchemaProcessor.formatForDisplay(response.data, 'json');
                    responseBody.innerHTML = formatted;
                } else {
                    const codeElement = responseBody.querySelector('code');
                    if (codeElement) {
                        codeElement.textContent = this.formatJSON(response.data);
                    }
                }
            }

            // Update response headers with proper formatting
            const responseHeaders = document.getElementById('response-headers');
            if (responseHeaders) {
                if (typeof SchemaProcessor !== 'undefined') {
                    const formatted = SchemaProcessor.formatForDisplay(response.headers || {}, 'json');
                    responseHeaders.innerHTML = formatted;
                } else {
                    const codeElement = responseHeaders.querySelector('code');
                    if (codeElement) {
                        const headersText = Object.entries(response.headers || {})
                            .map(([key, value]) => `${key}: ${value}`)
                            .join('\n');
                        codeElement.textContent = headersText;
                    }
                }
            }

            // Ensure body tab is active
            this.activateResponseTab('body');
        },

        // Display error response in sidebar
        displayError(error, endpoint) {
            // Update response status for error
            this.updateResponseStatus('Error', error.message, 0);

            // Hide empty state, show response content
            const emptyState = document.getElementById('response-empty-state');
            const copyBtn = document.getElementById('copy-response-btn');
            if (emptyState) emptyState.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'block';

            // Show error in response body with proper formatting
            const responseBody = document.getElementById('response-body');
            if (responseBody) {
                responseBody.style.display = 'block';
                const errorInfo = {
                    error: error.message || 'Unknown error occurred',
                    ...(error.response && {
                        status: error.response.status,
                        statusText: error.response.statusText,
                        response: error.response.data
                    })
                };

                if (typeof SchemaProcessor !== 'undefined') {
                    const formatted = SchemaProcessor.formatForDisplay(errorInfo, 'json');
                    responseBody.innerHTML = formatted;
                } else {
                    const codeElement = responseBody.querySelector('code');
                    if (codeElement) {
                        codeElement.textContent = this.formatJSON(errorInfo);
                    }
                }
            }

            // Clear headers
            const responseHeaders = document.getElementById('response-headers');
            if (responseHeaders) {
                const codeElement = responseHeaders.querySelector('code');
                if (codeElement) {
                    codeElement.textContent = error.response ?
                        Object.entries(error.response.headers || {})
                            .map(([key, value]) => `${key}: ${value}`)
                            .join('\n') :
                        'No headers available';
                }
            }

            // Ensure body tab is active
            this.activateResponseTab('body');
        },

        // Initialize response tab functionality
        initializeResponseTabs(container) {
            const tabBtns = container.querySelectorAll('.tab-btn');
            const tabPanels = container.querySelectorAll('.tab-panel');

            tabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabName = btn.getAttribute('data-tab');

                    // Update active states
                    tabBtns.forEach(b => b.classList.remove('active'));
                    tabPanels.forEach(p => p.classList.remove('active'));

                    btn.classList.add('active');
                    const panel = container.querySelector(`[data-panel="${tabName}"]`);
                    if (panel) {
                        panel.classList.add('active');
                    }
                });
            });
        },

        // Get CSS class for HTTP status code
        // Get status class for styling
        getStatusClass(status) {
            if (typeof status === 'string') {
                if (status.toLowerCase().includes('error')) return 'status-error';
                if (status.toLowerCase().includes('success')) return 'status-success';
                return 'status-unknown';
            }
            if (status >= 200 && status < 300) return 'status-success';
            if (status >= 300 && status < 400) return 'status-info';
            if (status >= 400 && status < 500) return 'status-warning';
            if (status >= 500) return 'status-error';
            return 'status-unknown';
        },

        // Update response status in sidebar
        updateResponseStatus(status, statusText, duration) {
            const statusEl = document.querySelector('#response-status-info .status-badge');
            const timeEl = document.querySelector('#response-status-info .response-time');

            if (statusEl) {
                statusEl.className = `status-badge ${this.getStatusClass(status)}`;
                statusEl.textContent = `${status} ${statusText || ''}`.trim();
            }

            if (timeEl) {
                timeEl.textContent = duration ? `${duration}ms` : '';
            }
        },

        // Activate specific response tab
        activateResponseTab(tabName) {
            // Update tab buttons
            const tabButtons = document.querySelectorAll('.response-tab');
            tabButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            // Update tab content visibility
            const responseBody = document.getElementById('response-body');
            const responseHeaders = document.getElementById('response-headers');

            if (responseBody) {
                responseBody.style.display = tabName === 'body' ? 'block' : 'none';
            }
            if (responseHeaders) {
                responseHeaders.style.display = tabName === 'headers' ? 'block' : 'none';
            }
        },

        // Format JSON for display
        formatJSON(data) {
            if (!data) return 'No data';

            if (typeof data === 'string') {
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    return data; // Return as-is if not valid JSON
                }
            }

            return JSON.stringify(data, null, 2);
        },

        // Build cURL command for the request
        generateCurlCommand(endpoint, formData, authToken = null) {
            const config = this.buildRequestConfig(endpoint, formData, authToken);

            let curl = `curl -X ${config.method}`;

            // Add headers
            Object.entries(config.headers).forEach(([key, value]) => {
                curl += ` -H "${key}: ${value}"`;
            });

            // Add body if present
            if (config.body) {
                curl += ` -d '${config.body}'`;
            }

            // Add URL (quote it to handle query parameters)
            curl += ` "${config.url}"`;

            return curl;
        },

        // Copy cURL command to clipboard
        copyCurlCommand(endpoint) {
            try {
                const validation = APIFormBuilder.validateForm(endpoint);
                if (!validation.valid) {
                    throw new Error('Form validation failed');
                }

                const curlCommand = this.generateCurlCommand(endpoint, validation.data);

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(curlCommand).then(() => {
                        this.showToast('cURL command copied to clipboard!', 'success');
                    });
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = curlCommand;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    this.showToast('cURL command copied to clipboard!', 'success');
                }
            } catch (error) {
                this.showToast('Failed to generate cURL command: ' + error.message, 'error');
            }
        },

        // Show toast notification
        showToast(message, type = 'info') {
            // Simple toast implementation
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 15px;
                background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'};
                color: white;
                border-radius: 4px;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.3s;
            `;

            document.body.appendChild(toast);

            // Fade in
            setTimeout(() => toast.style.opacity = '1', 10);

            // Fade out and remove
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }
    };
{{end}}
