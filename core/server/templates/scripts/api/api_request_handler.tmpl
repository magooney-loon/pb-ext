{{define "api_request_handler_js"}}
    // =============================================================================
    // SIMPLIFIED API REQUEST HANDLER - USES NEW OPENAPI SCHEMA MANAGER
    // =============================================================================

    const APIRequestHandler = {

        // Send HTTP request using simplified form data and OpenAPI schema
        async sendRequest(endpoint, authToken = null) {
            if (!endpoint) {
                console.error('No endpoint provided for request');
                this.showError('No endpoint selected for request');
                return;
            }

            try {
                // Clear previous response first
                this.clearResponse();

                // Show loading state
                this.updateStatus('loading', 'Sending request...');

                // Collect and validate form data
                const formData = APIFormBuilder.collectFormData();
                const validation = APISchemaManager.validateRequestData(endpoint, formData);

                if (!validation.valid) {
                    throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
                }

                // Build request configuration
                const requestConfig = this.buildRequestConfig(endpoint, formData, authToken);

                // Execute request
                const response = await this.executeRequest(requestConfig);

                // Display successful response
                this.displayResponse(response, endpoint);

                // Auto-switch to response tab
                if (typeof APITesterSidebar !== 'undefined' && APITesterSidebar.switchTab) {
                    APITesterSidebar.switchTab('response');
                }

                return response;

            } catch (error) {
                console.error('Request failed:', error);
                this.displayError(error, endpoint);

                // Switch to response tab to show error
                if (typeof APITesterSidebar !== 'undefined' && APITesterSidebar.switchTab) {
                    APITesterSidebar.switchTab('response');
                }
            } finally {
                // Restore button state
                this.updateSendButton(sendBtn, false, originalBtnContent);
            }
        },

        // Build request configuration from endpoint and form data
        buildRequestConfig(endpoint, formData, authToken) {
            // Build URL with path parameters
            const url = APISchemaManager.buildUrl(endpoint, formData.pathParams);

            // Prepare request body
            const body = APISchemaManager.prepareRequestBody(endpoint, formData);

            // Build headers
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            };

            // Add authentication only if token is provided
            if (authToken && APISchemaManager.requiresAuth(endpoint)) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            // Add query parameters to URL
            const finalUrl = this.addQueryParameters(url, formData.queryParams);

            return {
                method: endpoint.method.toUpperCase(),
                url: finalUrl,
                headers: headers,
                body: body ? JSON.stringify(body) : null
            };
        },

        // Execute the HTTP request
        async executeRequest(config) {
            const startTime = Date.now();

            const response = await fetch(config.url, {
                method: config.method,
                headers: config.headers,
                body: config.body
            });

            const endTime = Date.now();
            const duration = endTime - startTime;

            // Parse response data
            let responseData;
            const contentType = response.headers.get('content-type');

            if (contentType && contentType.includes('application/json')) {
                try {
                    responseData = await response.json();
                } catch (e) {
                    responseData = await response.text();
                }
            } else {
                responseData = await response.text();
            }

            // Return normalized response object
            return {
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers.entries()),
                data: responseData,
                duration: duration,
                url: config.url,
                method: config.method
            };
        },

        // Add query parameters to URL
        addQueryParameters(url, queryParams) {
            if (!queryParams || Object.keys(queryParams).length === 0) {
                return url;
            }

            const urlObj = new URL(url, window.location.origin);
            Object.entries(queryParams).forEach(([key, value]) => {
                if (value !== null && value !== undefined && value !== '') {
                    urlObj.searchParams.append(key, String(value));
                }
            });

            return urlObj.pathname + urlObj.search;
        },

        // Display successful response
        displayResponse(response, endpoint) {
            this.updateStatus('success', `${response.status} ${response.statusText} (${response.duration}ms)`);
            this.updateResponseStatus(response.status, response.statusText, response.duration);

            // Hide empty state and show response content
            const emptyState = document.getElementById('response-empty-state');
            const responseBody = document.getElementById('response-body');
            const responseHeaders = document.getElementById('response-headers');
            const copyBtn = document.getElementById('copy-response-btn');

            if (emptyState) emptyState.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'inline-block';

            // Display response body and headers content
            this.displayResponseBody(response);
            this.displayResponseHeaders(response);

            // Show the appropriate tab based on current selection, default to body
            const activeResponseTab = document.querySelector('.response-tab.active');
            const currentTab = activeResponseTab ? activeResponseTab.dataset.tab : 'body';

            if (currentTab === 'body') {
                if (responseBody) {
                    responseBody.style.display = 'block';
                    responseBody.classList.add('active');
                }
                if (responseHeaders) {
                    responseHeaders.style.display = 'none';
                    responseHeaders.classList.remove('active');
                }
            } else {
                if (responseBody) {
                    responseBody.style.display = 'none';
                    responseBody.classList.remove('active');
                }
                if (responseHeaders) {
                    responseHeaders.style.display = 'block';
                    responseHeaders.classList.add('active');
                }
            }

            // Update request info
            this.updateRequestInfo(response, endpoint);

            // Notify sidebar if it exists
            if (typeof APITesterSidebar !== 'undefined' && APITesterSidebar._switchResponseTab) {
                APITesterSidebar._switchResponseTab(currentTab);
            }
        },

        // Display error response
        displayError(error, endpoint) {
            console.error('Request error:', error);

            this.updateStatus('error', error.message);

            // Try to show error details in response area
            const errorResponse = {
                ok: false,
                status: 0,
                statusText: 'Request Failed',
                data: {
                    error: error.message,
                    timestamp: new Date().toISOString(),
                    endpoint: endpoint ? `${endpoint.method} ${endpoint.path}` : 'unknown'
                },
                headers: {},
                duration: 0
            };

            this.displayResponse(errorResponse, endpoint);
        },
        // Update response status display in UI
        updateResponseStatus(status, statusText, time) {
            const statusEl = document.querySelector('#response-status-info .status-badge');
            const timeEl = document.querySelector('#response-status-info .response-time');

            if (statusEl) {
                if (typeof status === 'number' && status > 0) {
                    statusEl.textContent = `${status} ${statusText}`;

                    // Apply semantic colors based on HTTP status codes
                    let statusClass = 'status-badge';
                    if (status >= 200 && status < 300) {
                        statusClass += ' txt-success'; // Green for success (2xx)
                    } else if (status >= 300 && status < 400) {
                        statusClass += ' txt-warning'; // Yellow for redirects (3xx)
                    } else if (status >= 400 && status < 500) {
                        statusClass += ' txt-danger'; // Red for client errors (4xx)
                    } else if (status >= 500) {
                        statusClass += ' txt-danger'; // Red for server errors (5xx)
                    } else {
                        statusClass += ' txt-hint'; // Gray for other statuses
                    }

                    statusEl.className = statusClass;
                } else {
                    statusEl.textContent = typeof status === 'string' ? status : 'Ready';
                    statusEl.className = 'status-badge txt-hint';
                }
            }

            if (timeEl) {
                if (typeof time === 'number' && time > 0) {
                    timeEl.textContent = `${time}ms`;
                } else {
                    timeEl.textContent = typeof statusText === 'string' ? statusText : 'Send a request';
                }
            }
        },

        // Clear response status display
        clearResponseStatus() {
            this.updateResponseStatus('Ready', 'Send a request', 0);
        },

        // Display response body with syntax highlighting
        displayResponseBody(response) {
            const bodyEl = document.getElementById('response-body');
            if (!bodyEl) {
                return;
            }

            // Find the existing code element in the sidebar structure
            const codeEl = bodyEl.querySelector('code');
            if (!codeEl) {
                // Create the structure if it doesn't exist
                bodyEl.innerHTML = '<pre class="code-block"><code></code></pre>';
                const newCodeEl = bodyEl.querySelector('code');
                if (!newCodeEl) {
                    return;
                }
            }

            const finalCodeEl = bodyEl.querySelector('code');
            if (!response.data) {
                finalCodeEl.textContent = 'No response body';
                return;
            }

            // Use SchemaProcessor for syntax highlighting if available
            if (typeof SchemaProcessor !== 'undefined') {
                try {
                    const formatted = SchemaProcessor.syntaxHighlight(response.data, 'json');
                    finalCodeEl.innerHTML = formatted;
                } catch (e) {
                    // Fallback to plain text with escaping
                    const content = typeof response.data === 'string' ?
                        response.data : JSON.stringify(response.data, null, 2);
                    finalCodeEl.textContent = content;
                }
            } else {
                // Simple fallback
                const content = typeof response.data === 'string' ?
                    response.data : JSON.stringify(response.data, null, 2);
                finalCodeEl.textContent = content;
            }
        },

        // Display response headers
        displayResponseHeaders(response) {
            const headersEl = document.getElementById('response-headers');
            if (!headersEl) {
                return;
            }

            // Find the existing code element in the sidebar structure
            const codeEl = headersEl.querySelector('code');
            if (!codeEl) {
                // Create the structure if it doesn't exist
                headersEl.innerHTML = '<pre class="code-block"><code></code></pre>';
                const newCodeEl = headersEl.querySelector('code');
                if (!newCodeEl) {
                    return;
                }
            }

            const finalCodeEl = headersEl.querySelector('code');
            if (!response.headers || Object.keys(response.headers).length === 0) {
                finalCodeEl.textContent = 'No response headers';
                return;
            }

            // Use SchemaProcessor for formatting if available
            if (typeof SchemaProcessor !== 'undefined') {
                try {
                    const formatted = SchemaProcessor.syntaxHighlight(response.headers, 'json');
                    finalCodeEl.innerHTML = formatted;
                } catch (e) {
                    const content = JSON.stringify(response.headers, null, 2);
                    finalCodeEl.textContent = content;
                }
            } else {
                const content = JSON.stringify(response.headers, null, 2);
                finalCodeEl.textContent = content;
            }
        },

        // Update request information display
        updateRequestInfo(response, endpoint) {
            const requestInfoEl = document.getElementById('request-info');
            if (requestInfoEl) {
                requestInfoEl.innerHTML = `
                    <div class="request-summary">
                        <div><strong>Method:</strong> ${response.method}</div>
                        <div><strong>URL:</strong> ${response.url}</div>
                        <div><strong>Status:</strong> ${response.status} ${response.statusText}</div>
                        <div><strong>Duration:</strong> ${response.duration}ms</div>
                    </div>
                `;
            }
        },

        // Update send button state
        updateSendButton(button, loading, originalContent = 'Send Request') {
            if (!button) return;

            if (loading) {
                button.disabled = true;
                button.innerHTML = '<i class="ri-loader-4-line ri-spin"></i> Sending...';
            } else {
                button.disabled = false;
                button.innerHTML = originalContent;
            }
        },

        // Update status message
        updateStatus(type, message) {
            if (typeof ErrorStatusManager !== 'undefined') {
                ErrorStatusManager.updateStatus(type, message);
            } else if (typeof StatusManager !== 'undefined') {
                StatusManager.updateStatus(type, message);
            }
        },

        // Show error message
        showError(message) {
            this.updateStatus('error', message);
        },

        // Simple HTML escaping fallback
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        // Clear response display
        clearResponse() {
            const responseBody = document.getElementById('response-body');
            const responseHeaders = document.getElementById('response-headers');
            const requestInfo = document.getElementById('request-info');
            const emptyState = document.getElementById('response-empty-state');
            const copyBtn = document.getElementById('copy-response-btn');

            // Show empty state and hide response content
            if (emptyState) emptyState.style.display = 'block';
            if (responseBody) {
                responseBody.style.display = 'none';
                responseBody.classList.remove('active');
            }
            if (responseHeaders) {
                responseHeaders.style.display = 'none';
                responseHeaders.classList.remove('active');
            }
            if (copyBtn) copyBtn.style.display = 'none';

            // Clear content
            if (responseBody) {
                const bodyCodeEl = responseBody.querySelector('code');
                if (bodyCodeEl) {
                    bodyCodeEl.textContent = '';
                }
            }
            if (responseHeaders) {
                const headersCodeEl = responseHeaders.querySelector('code');
                if (headersCodeEl) {
                    headersCodeEl.textContent = '';
                }
            }

            if (requestInfo) requestInfo.innerHTML = '';

            // Reset both system status and response status display
            this.updateStatus('info', 'Ready');
            this.clearResponseStatus();

            // Reset response tabs to default (body)
            const responseTabs = document.querySelectorAll('.response-tab');
            responseTabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === 'body');
            });
        },



        // Get authentication token helper
        getAuthToken() {
            if (window.APILoader && window.APILoader.getSuperuserAuthToken) {
                return window.APILoader.getSuperuserAuthToken();
            }

            // Fallback: check localStorage directly
            try {
                const authData = localStorage.getItem('__pb_superuser_auth__');
                if (authData) {
                    const parsed = JSON.parse(authData);
                    return parsed.token;
                }
            } catch (e) {
                // Silent fallback
            }

            return null;
        }
    };

    // Export for global use
    if (typeof window !== 'undefined') {
        window.APIRequestHandler = APIRequestHandler;
    }

{{end}}
