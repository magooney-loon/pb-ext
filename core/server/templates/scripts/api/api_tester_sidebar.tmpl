{{define "api_tester_sidebar_js"}}
    // =============================================================================
    // API TESTER SIDEBAR - CONSOLIDATED WITH SYNTAX HIGHLIGHTING
    // =============================================================================

    const APITesterSidebar = {
        isOpen: false,
        currentEndpoint: null,
        initialized: false,
        _eventCleanup: [],

        // Initialize the sidebar controller
        init() {
            if (this.initialized) {
                return;
            }

            console.log('Initializing API Tester Sidebar...');

            try {
                this._bindEvents();
                this._initializeTabs();
                this.initialized = true;
                console.log('API Tester Sidebar initialized successfully');
            } catch (error) {
                console.error('Failed to initialize API Tester Sidebar:', error);
                if (typeof ErrorStatusManager !== 'undefined') {
                    ErrorStatusManager.handleError(error, 'APITesterSidebar.init');
                }
            }
        },

        // Initialize tab controllers for sidebar
        _initializeTabs() {
            // Initialize main tester tabs (parameters/response)
            this._initializeTesterTabs();
            // Initialize response sub-tabs (body/headers)
            this._initializeResponseTabs();
        },

        // Initialize main tester tabs
        _initializeTesterTabs() {
            const tabButtons = this._safeQueryAll('.api-tester-tabs .tester-tab');

            tabButtons.forEach(button => {
                const cleanup = this._addListener(button, 'click', (e) => {
                    e.preventDefault();
                    this._switchTesterTab(button.dataset.tab);
                });

                if (cleanup) {
                    this._eventCleanup.push(cleanup);
                }
            });

            // Ensure parameters tab is active by default
            this._switchTesterTab('parameters');
        },

        // Initialize response tabs
        _initializeResponseTabs() {
            const responseTabButtons = this._safeQueryAll('.response-tabs .response-tab');

            responseTabButtons.forEach(button => {
                const cleanup = this._addListener(button, 'click', (e) => {
                    e.preventDefault();
                    this._switchResponseTab(button.dataset.tab);
                });

                if (cleanup) {
                    this._eventCleanup.push(cleanup);
                }
            });

            // Default to body tab and ensure empty state is shown initially
            this._switchResponseTab('body');
            this._showEmptyResponseState();
        },

        // Show empty response state
        _showEmptyResponseState() {
            const emptyState = this._getElementById('response-empty-state');
            const bodyContent = this._getElementById('response-body');
            const headersContent = this._getElementById('response-headers');
            const copyBtn = this._getElementById('copy-response-btn');

            if (emptyState) emptyState.style.display = 'block';
            if (bodyContent) bodyContent.style.display = 'none';
            if (headersContent) headersContent.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'none';
        },

        // Hide empty response state and show content
        _hideEmptyResponseState() {
            const emptyState = this._getElementById('response-empty-state');
            const copyBtn = this._getElementById('copy-response-btn');

            if (emptyState) emptyState.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'block';

            // Show the active response tab
            const activeTab = document.querySelector('.response-tab.active');
            if (activeTab) {
                const tabName = activeTab.dataset.tab;
                this._switchResponseTab(tabName);
            } else {
                this._switchResponseTab('body');
            }
        },

        // Method to be called when a response is received
        showResponseContent() {
            this._hideEmptyResponseState();
        },

        // Bind event listeners
        _bindEvents() {
            // Sidebar controls
            const closeBtn = this._getElementById('close-tester-btn');
            const copyBtn = this._getElementById('copy-response-btn');
            const copySchemaBtn = this._getElementById('copy-schema-btn');
            const sendAdminBtn = this._getElementById('send-request-admin-btn');
            const sendAuthBtn = this._getElementById('send-request-auth-btn');
            const sendGuestBtn = this._getElementById('send-request-guest-btn');
            const resetBtn = this._getElementById('reset-form-btn');

            if (closeBtn) {
                const cleanup = this._addListener(closeBtn, 'click', () => this.closeSidebar());
                if (cleanup) this._eventCleanup.push(cleanup);
            }

            if (copyBtn) {
                const cleanup = this._addListener(copyBtn, 'click', () => this._copyResponse());
                if (cleanup) this._eventCleanup.push(cleanup);
            }

            if (copySchemaBtn) {
                const cleanup = this._addListener(copySchemaBtn, 'click', () => this._copySchema());
                if (cleanup) this._eventCleanup.push(cleanup);
            }

            if (sendAdminBtn) {
                const cleanup = this._addListener(sendAdminBtn, 'click', () => this._sendRequest('admin'));
                if (cleanup) this._eventCleanup.push(cleanup);
            }

            if (sendAuthBtn) {
                const cleanup = this._addListener(sendAuthBtn, 'click', () => this._sendRequest('auth'));
                if (cleanup) this._eventCleanup.push(cleanup);
            }

            if (sendGuestBtn) {
                const cleanup = this._addListener(sendGuestBtn, 'click', () => this._sendRequest('guest'));
                if (cleanup) this._eventCleanup.push(cleanup);
            }

            if (resetBtn) {
                const cleanup = this._addListener(resetBtn, 'click', () => this._resetForm());
                if (cleanup) this._eventCleanup.push(cleanup);
            }

            // Escape key to close sidebar
            const escapeHandler = (e) => {
                if (e.key === 'Escape' && this.isOpen) {
                    this.closeSidebar();
                }
            };
            document.addEventListener('keydown', escapeHandler);
            this._eventCleanup.push(() => document.removeEventListener('keydown', escapeHandler));

            // Listen to custom events from other components
            const responseHandler = (e) => this._handleResponseReceived(e.detail);
            document.addEventListener('apiResponseReceived', responseHandler);
            this._eventCleanup.push(() => document.removeEventListener('apiResponseReceived', responseHandler));
        },

        // Switch tester tabs with improved error handling
        _switchTesterTab(tabName) {
            if (!tabName) {
                console.warn('Tab name is required for switching');
                return;
            }

            try {
                // Update button states
                this._safeQueryAll('.tester-tab').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabName);
                });

                // Update content visibility
                this._safeQueryAll('.tester-tab-content').forEach(content => {
                    const isActive = content.id === `${tabName}-tab`;
                    content.classList.toggle('active', isActive);
                    content.style.display = isActive ? 'block' : 'none';

                    // Scroll to top when switching tabs
                    if (isActive) {
                        content.scrollTop = 0;
                    }
                });

                // Trigger refresh event for other components
                this._triggerTabChange(tabName);

                console.log(`Switched to tester tab: ${tabName}`);
            } catch (error) {
                console.error('Failed to switch tester tab:', error);
            }
        },

        // Switch response sub-tabs with syntax highlighting updates
        _switchResponseTab(tabName) {
            if (!tabName) {
                console.warn('Response tab name is required');
                return;
            }

            try {
                // Update button states
                this._safeQueryAll('.response-tab').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabName);
                });

                // Update content visibility - fix the ID matching
                const bodyContent = this._getElementById('response-body');
                const headersContent = this._getElementById('response-headers');
                const emptyState = this._getElementById('response-empty-state');

                // Check if we have response content in a more robust way
                const bodyCode = bodyContent ? bodyContent.querySelector('code') : null;
                const hasResponse = bodyCode && bodyCode.textContent.trim() &&
                    !bodyCode.textContent.includes('No response yet') &&
                    bodyCode.textContent !== '';

                if (!hasResponse) {
                    // Show empty state, hide content
                    if (emptyState) emptyState.style.display = 'block';
                    if (bodyContent) bodyContent.style.display = 'none';
                    if (headersContent) headersContent.style.display = 'none';
                } else {
                    // Hide empty state, show appropriate content
                    if (emptyState) emptyState.style.display = 'none';

                    // Show the selected tab content
                    if (bodyContent) {
                        bodyContent.classList.toggle('active', tabName === 'body');
                        bodyContent.style.display = tabName === 'body' ? 'block' : 'none';
                    }

                    if (headersContent) {
                        headersContent.classList.toggle('active', tabName === 'headers');
                        headersContent.style.display = tabName === 'headers' ? 'block' : 'none';
                    }

                    // Re-apply syntax highlighting when tab becomes visible
                    if (typeof SchemaProcessor !== 'undefined') {
                        if (tabName === 'body' && bodyContent) {
                            this._refreshSyntaxHighlighting(bodyContent);
                        } else if (tabName === 'headers' && headersContent) {
                            this._refreshSyntaxHighlighting(headersContent);
                        }
                    }
                }

                console.log(`Switched to response tab: ${tabName}`);
            } catch (error) {
                console.error('Failed to switch response tab:', error);
            }
        },

        // Refresh syntax highlighting for visible content
        _refreshSyntaxHighlighting(container) {
            if (!container || typeof SchemaProcessor === 'undefined') return;

            try {
                const codeElements = container.querySelectorAll('code');
                codeElements.forEach(codeEl => {
                    if (codeEl.textContent.trim()) {
                        try {
                            const data = JSON.parse(codeEl.textContent);
                            const highlighted = SchemaProcessor.syntaxHighlight(data);
                            codeEl.innerHTML = highlighted;
                        } catch {
                            // If not JSON, just apply basic highlighting
                            codeEl.innerHTML = SchemaProcessor.escapeHtml(codeEl.textContent);
                        }
                    }
                });
            } catch (error) {
                console.warn('Failed to refresh syntax highlighting:', error);
            }
        },

        // Trigger tab change event
        _triggerTabChange(tabName) {
            try {
                const event = new CustomEvent('apiTesterTabChange', {
                    detail: {
                        tab: tabName,
                        endpoint: this.currentEndpoint,
                        sidebar: this
                    }
                });
                document.dispatchEvent(event);
            } catch (error) {
                console.warn('Failed to trigger tab change event:', error);
            }
        },

        // Open sidebar with comprehensive endpoint data processing
        openSidebar(method, path, endpointData) {
            try {
                // Prevent duplicate opening of same endpoint
                if (this.isOpen && this.currentEndpoint &&
                    this.currentEndpoint.method === method.toUpperCase() &&
                    this.currentEndpoint.path === path) {
                    console.log('Same endpoint already open in sidebar');
                    return;
                }

                // Parse endpoint data if needed
                let parsedData = this._parseEndpointData(endpointData);

                this.currentEndpoint = {
                    method: method.toUpperCase(),
                    path: path,
                    data: parsedData
                };

                // Update UI components
                this._updateEndpointInfo();

                // Update schema display with proper timing
                setTimeout(() => {
                    this._updateSchemaDisplay();
                }, 50);

                // Reset to parameters tab
                this._switchTesterTab('parameters');

                // Reset response state
                this._resetResponseState();

                // Show sidebar
                this._showSidebar();

                // Trigger event for other components
                this._triggerSidebarOpened();

                console.log(`Opened API tester for: ${method.toUpperCase()} ${path}`);

            } catch (error) {
                console.error('Failed to open sidebar:', error);
                if (typeof ErrorStatusManager !== 'undefined') {
                    ErrorStatusManager.handleError(error, 'APITesterSidebar.openSidebar');
                }
            }
        },

        // Parse endpoint data safely
        _parseEndpointData(endpointData) {
            if (!endpointData) return {};

            if (typeof endpointData === 'string') {
                try {
                    return JSON.parse(endpointData);
                } catch (error) {
                    console.warn('Failed to parse endpoint data as JSON:', error);
                    return {};
                }
            }

            if (typeof endpointData === 'object') {
                return endpointData;
            }

            return {};
        },

        // Update schema display using APIFormBuilder
        _updateSchemaDisplay() {
            if (!this.currentEndpoint) return;

            try {
                const container = this._getElementById('schema-form-container');
                if (!container) {
                    console.error('Schema form container not found');
                    return;
                }

                // Clear existing content
                container.innerHTML = `
                    <div class="txt-center txt-hint">
                        <i class="ri-loader-4-line animate-spin"></i>
                        <p>Loading schema...</p>
                    </div>
                `;

                const { data } = this.currentEndpoint;

                // Use APIFormBuilder to generate the parameter form
                if (typeof APIFormBuilder !== 'undefined') {
                    console.log('Generating parameter form for endpoint:', data);

                    // Generate form with a small delay to ensure proper rendering
                    setTimeout(() => {
                        try {
                            APIFormBuilder.generateParameterForm(container, data);

                            // Initialize URL updating after form is built
                            setTimeout(() => {
                                if (APIFormBuilder.initUrlUpdating) {
                                    APIFormBuilder.initUrlUpdating();
                                }
                                if (APIFormBuilder.updateUrlDisplay) {
                                    APIFormBuilder.updateUrlDisplay();
                                }
                            }, 100);
                        } catch (formError) {
                            console.error('Error generating form:', formError);
                            container.innerHTML = `
                                <div class="txt-center txt-danger p-3">
                                    <i class="ri-error-warning-line"></i>
                                    <p>Error generating form: ${formError.message}</p>
                                </div>
                            `;
                        }
                    }, 10);

                } else {
                    console.error('APIFormBuilder not available');
                    container.innerHTML = `
                        <div class="txt-center txt-danger p-3">
                            <i class="ri-error-warning-line"></i>
                            <p>APIFormBuilder not available</p>
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Failed to update schema display:', error);
                const container = this._getElementById('schema-form-container');
                if (container) {
                    container.innerHTML = `
                        <div class="txt-center txt-danger p-3">
                            <i class="ri-error-warning-line"></i>
                            <p>Error loading form</p>
                            <small>${error.message}</small>
                        </div>
                    `;
                }
            }
        },

        // Update examples display
        _updateExamples() {
            if (!this.currentEndpoint || typeof SchemaProcessor === 'undefined') return;

            try {
                const { data } = this.currentEndpoint;

                // Extract and display request examples
                if (data.request) {
                    const requestExamples = SchemaProcessor.extractExamples(data.request);
                    if (requestExamples) {
                        this._displayExamples('request-examples', requestExamples);
                    }
                }

                // Extract and display response examples
                if (data.response) {
                    const responseExamples = SchemaProcessor.extractExamples(data.response);
                    if (responseExamples) {
                        this._displayExamples('response-examples', responseExamples);
                    }
                }

            } catch (error) {
                console.warn('Failed to update examples:', error);
            }
        },

        // Display examples with syntax highlighting
        _displayExamples(containerId, examples) {
            const container = this._getElementById(containerId);
            if (!container || !examples || !Array.isArray(examples)) return;

            try {
                const examplesHtml = examples.map((example, index) => `
                    <div class="example-item">
                        <div class="example-header">
                            <strong>${example.summary || example.name || `Example ${index + 1}`}</strong>
                            ${example.description ? `<div class="txt-sm txt-hint">${example.description}</div>` : ''}
                        </div>
                        <div class="example-content">
                            ${SchemaProcessor.formatForDisplay(example.value, 'json')}
                        </div>
                    </div>
                `).join('');

                container.innerHTML = examplesHtml;
            } catch (error) {
                console.warn('Failed to display examples:', error);
            }
        },

        // Close sidebar with cleanup
        closeSidebar() {
            try {
                this._hideSidebar();
                this._triggerSidebarClosed();
                this.currentEndpoint = null;
                console.log('API tester sidebar closed');
            } catch (error) {
                console.error('Failed to close sidebar:', error);
            }
        },

        // Show sidebar UI
        _showSidebar() {
            const sidebar = this._getElementById('api-tester-sidebar');
            const overlay = this._getElementById('sidebar-overlay');

            if (sidebar) {
                sidebar.classList.add('open');
            }

            if (overlay) {
                overlay.style.display = 'block';
            }

            // Disable body scroll
            document.body.classList.add('sidebar-open');

            this.isOpen = true;
        },

        // Hide sidebar UI
        _hideSidebar() {
            const sidebar = this._getElementById('api-tester-sidebar');
            const overlay = this._getElementById('sidebar-overlay');

            if (sidebar) {
                sidebar.classList.remove('open');
            }

            if (overlay) {
                overlay.style.display = 'none';
            }

            // Re-enable body scroll
            document.body.classList.remove('sidebar-open');

            this.isOpen = false;
        },

        // Update endpoint info display with enhanced auth detection
        _updateEndpointInfo() {
            if (!this.currentEndpoint) return;

            try {
                const methodEl = this._getElementById('tester-method');
                const pathEl = this._getElementById('tester-path');
                const descEl = this._getElementById('tester-description');
                const authEl = this._getElementById('tester-auth-info');

                if (methodEl) {
                    methodEl.textContent = this.currentEndpoint.method;
                    methodEl.className = `http-method method-${this.currentEndpoint.method.toLowerCase()}`;
                }

                if (pathEl) {
                    pathEl.textContent = this.currentEndpoint.path;

                    // Initialize URL updating after a brief delay to ensure form is built
                    setTimeout(() => {
                        if (window.APIFormBuilder && window.APIFormBuilder.updateUrlDisplay) {
                            window.APIFormBuilder.updateUrlDisplay();
                        }
                    }, 200);
                }

                if (descEl) {
                    const description = this.currentEndpoint.data.description ||
                                     'Test this API endpoint with custom parameters and view responses';
                    descEl.textContent = description;
                }

                if (authEl) {
                    this._updateAuthInfo(authEl);
                }

            } catch (error) {
                console.warn('Failed to update endpoint info:', error);
            }
        },

        // Update authentication info display
        _updateAuthInfo(authEl) {
            if (!authEl || !this.currentEndpoint) return;

            try {
                const { data } = this.currentEndpoint;
                const authInfo = this._analyzeAuth(data);

                const badge = authEl.querySelector('.auth-badge');
                if (badge) {
                    if (authInfo.required) {
                        badge.textContent = `🔐 ${authInfo.type} required`;
                        badge.className = 'auth-badge auth-required';
                        badge.title = authInfo.description || 'Authentication is required for this endpoint';
                    } else {
                        badge.textContent = '🔓 No auth required';
                        badge.className = 'auth-badge auth-optional';
                        badge.title = 'This endpoint is publicly accessible';
                    }
                }

                // Update auth details section if present
                const authDetails = authEl.querySelector('.auth-details');
                if (authDetails && authInfo.required) {
                    authDetails.innerHTML = `
                        <div class="auth-requirement">
                            <strong>Required:</strong> ${authInfo.type}
                        </div>
                        ${authInfo.description ? `<div class="auth-description">${authInfo.description}</div>` : ''}
                        ${authInfo.scopes ? `<div class="auth-scopes"><strong>Scopes:</strong> ${authInfo.scopes.join(', ')}</div>` : ''}
                    `;
                    authDetails.style.display = 'block';
                } else if (authDetails) {
                    authDetails.style.display = 'none';
                }

            } catch (error) {
                console.warn('Failed to update auth info:', error);
            }
        },

        // Analyze authentication requirements
        _analyzeAuth(endpointData) {
            const authInfo = {
                required: false,
                type: 'None',
                description: '',
                scopes: []
            };

            try {
                // Check direct auth property
                if (endpointData.auth) {
                    authInfo.required = Boolean(endpointData.auth.required);
                    authInfo.type = endpointData.auth.type || 'Unknown';
                    authInfo.description = endpointData.auth.description || '';
                }

                // Check OpenAPI security
                else if (endpointData.security && Array.isArray(endpointData.security) && endpointData.security.length > 0) {
                    authInfo.required = true;
                    const securityScheme = endpointData.security[0];
                    const schemeName = Object.keys(securityScheme)[0];
                    authInfo.type = schemeName || 'OAuth2/Bearer';
                    authInfo.scopes = securityScheme[schemeName] || [];
                }

                // Check alternative authorization field
                else if (endpointData.authorization) {
                    authInfo.required = Boolean(endpointData.authorization.required);
                    authInfo.type = endpointData.authorization.type || 'Unknown';
                    authInfo.description = endpointData.authorization.description || '';
                }

                return authInfo;

            } catch (error) {
                console.warn('Failed to analyze auth requirements:', error);
                return authInfo;
            }
        },

        // Reset response state
        _resetResponseState() {
            try {
                const emptyState = this._getElementById('response-empty-state');
                const responseBody = this._getElementById('response-body');
                const responseHeaders = this._getElementById('response-headers');
                const copyBtn = this._getElementById('copy-response-btn');

                if (emptyState) {
                    emptyState.style.display = 'flex';
                }

                if (copyBtn) {
                    copyBtn.style.display = 'none';
                }

                if (responseBody) {
                    responseBody.style.display = 'none';
                    // Clear both old and new response structure
                    responseBody.innerHTML = '<pre class="code-block"><code></code></pre>';
                }

                if (responseHeaders) {
                    responseHeaders.style.display = 'none';
                    // Clear both old and new response structure
                    responseHeaders.innerHTML = '<pre class="code-block"><code></code></pre>';
                }

                // Reset status display
                this._updateResponseStatus('Ready', 'Send a request', 0);

                // Reset to body tab
                this._switchResponseTab('body');

            } catch (error) {
                console.warn('Failed to reset response state:', error);
            }
        },

        // Handle response received event
        _handleResponseReceived(responseData) {
            if (!this.isOpen) return;

            try {
                // Show response content and hide empty state
                this._showResponseContent();

                // Update status
                this._updateResponseStatus(
                    responseData.status || 'Unknown',
                    responseData.statusText || '',
                    responseData.time || 0
                );

                // Update response content with syntax highlighting
                this._updateResponseContent(responseData.body, responseData.headers);

                // Auto-switch to response tab
                this._switchTesterTab('response');

            } catch (error) {
                console.error('Failed to handle response:', error);
            }
        },

        // Show response content and hide empty state
        _showResponseContent() {
            const emptyState = this._getElementById('response-empty-state');
            const responseBody = this._getElementById('response-body');
            const responseHeaders = this._getElementById('response-headers');
            const copyBtn = this._getElementById('copy-response-btn');

            if (emptyState) emptyState.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'inline-block';

            // Show content based on active tab
            const activeTab = this._safeQuery('.response-tab.active');
            const tabName = activeTab ? activeTab.dataset.tab : 'body';

            if (responseBody) {
                responseBody.classList.toggle('active', tabName === 'body');
                responseBody.style.display = tabName === 'body' ? 'block' : 'none';
            }

            if (responseHeaders) {
                responseHeaders.classList.toggle('active', tabName === 'headers');
                responseHeaders.style.display = tabName === 'headers' ? 'block' : 'none';
            }
        },

        // Update response status display
        _updateResponseStatus(status, statusText, time) {
            try {
                const statusEl = this._safeQuery('#response-status-info .status-badge');
                const timeEl = this._safeQuery('#response-status-info .response-time');

                if (statusEl) {
                    if (typeof status === 'number') {
                        statusEl.textContent = `${status} ${statusText}`;
                        statusEl.className = `status-badge status-${Math.floor(status / 100)}xx`;
                    } else {
                        statusEl.textContent = status;
                        statusEl.className = 'status-badge status-ready';
                    }
                }

                if (timeEl) {
                    if (typeof time === 'number' && time > 0) {
                        timeEl.textContent = `${time}ms`;
                    } else {
                        timeEl.textContent = typeof status === 'string' ? status : 'Ready';
                    }
                }

            } catch (error) {
                console.warn('Failed to update response status:', error);
            }
        },

        // Update response content with enhanced formatting
        _updateResponseContent(body, headers) {
            try {
                const bodyCode = this._safeQuery('#response-body code');
                const headersCode = this._safeQuery('#response-headers code');

                if (bodyCode && typeof SchemaProcessor !== 'undefined') {
                    if (body) {
                        try {
                            // Try to parse and format as JSON
                            const parsedBody = typeof body === 'string' ? JSON.parse(body) : body;
                            const formattedBody = SchemaProcessor.syntaxHighlight(parsedBody);
                            bodyCode.innerHTML = formattedBody;
                        } catch {
                            // If not JSON, display as plain text with escaping
                            bodyCode.innerHTML = SchemaProcessor.escapeHtml(String(body));
                        }
                    } else {
                        bodyCode.innerHTML = '<span class="json-null">No response body</span>';
                    }
                }

                if (headersCode && typeof SchemaProcessor !== 'undefined') {
                    if (headers && Object.keys(headers).length > 0) {
                        const formattedHeaders = SchemaProcessor.syntaxHighlight(headers);
                        headersCode.innerHTML = formattedHeaders;
                    } else {
                        headersCode.innerHTML = '<span class="json-null">No response headers</span>';
                    }
                }

            } catch (error) {
                console.warn('Failed to update response content:', error);
            }
        },

        // Copy response content
        _copyResponse() {
            try {
                // Try multiple selectors to find active response content
                let activeContent = this._safeQuery('.response-tab-content.active .code-block');
                if (!activeContent) {
                    activeContent = this._safeQuery('.response-tab-content.active code');
                }
                if (!activeContent) {
                    activeContent = this._safeQuery('.response-tab-content.active');
                }

                if (!activeContent?.textContent || activeContent.textContent.trim() === '') {
                    console.warn('No response content to copy');
                    this._showCopyFailure('copy-response-btn');
                    return;
                }

                navigator.clipboard.writeText(activeContent.textContent).then(() => {
                    this._showCopySuccess('copy-response-btn');
                }).catch(err => {
                    console.warn('Failed to copy response:', err);
                    this._showCopyFailure('copy-response-btn');
                });

            } catch (error) {
                console.warn('Failed to copy response:', error);
                this._showCopyFailure('copy-response-btn');
            }
        },

        // Copy schema content
        _copySchema() {
            try {
                const activeSchemaContent = this._safeQuery('.tester-tab-content.active .code-block');
                if (!activeSchemaContent?.textContent) {
                    console.warn('No schema content to copy');
                    return;
                }

                navigator.clipboard.writeText(activeSchemaContent.textContent).then(() => {
                    this._showCopySuccess('copy-schema-btn');
                }).catch(err => {
                    console.warn('Failed to copy schema:', err);
                    this._showCopyFailure('copy-schema-btn');
                });

            } catch (error) {
                console.warn('Failed to copy schema:', error);
            }
        },

        // Show copy success feedback
        _showCopySuccess(buttonId) {
            const btn = this._getElementById(buttonId);
            if (!btn) return;

            const originalHtml = btn.innerHTML;
            btn.innerHTML = '<i class="ri-check-line"></i>';
            btn.classList.add('btn-success');
            btn.classList.remove('btn-secondary');

            setTimeout(() => {
                btn.innerHTML = originalHtml;
                btn.classList.remove('btn-success');
                btn.classList.add('btn-secondary');
            }, 2000);
        },

        // Show copy failure feedback
        _showCopyFailure(buttonId) {
            const btn = this._getElementById(buttonId);
            if (!btn) return;

            const originalHtml = btn.innerHTML;
            btn.innerHTML = '<i class="ri-close-line"></i>';
            btn.classList.add('btn-danger');
            btn.classList.remove('btn-secondary');

            setTimeout(() => {
                btn.innerHTML = originalHtml;
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-secondary');
            }, 2000);
        },

        // Trigger sidebar opened event
        _triggerSidebarOpened() {
            try {
                const event = new CustomEvent('apiTesterSidebarOpened', {
                    detail: {
                        method: this.currentEndpoint.method,
                        path: this.currentEndpoint.path,
                        data: this.currentEndpoint.data,
                        sidebar: this
                    }
                });
                document.dispatchEvent(event);
            } catch (error) {
                console.warn('Failed to trigger sidebar opened event:', error);
            }
        },

        // Trigger sidebar closed event
        _triggerSidebarClosed() {
            try {
                const event = new CustomEvent('apiTesterSidebarClosed', {
                    detail: { sidebar: this }
                });
                document.dispatchEvent(event);
            } catch (error) {
                console.warn('Failed to trigger sidebar closed event:', error);
            }
        },

        // =============================================================================
        // UTILITY METHODS
        // =============================================================================

        _getElementById(id) {
            return document.getElementById(id);
        },

        _safeQuery(selector, context = document) {
            try {
                return context.querySelector(selector);
            } catch (error) {
                console.warn('Invalid selector:', selector, error);
                return null;
            }
        },

        _safeQueryAll(selector, context = document) {
            try {
                return Array.from(context.querySelectorAll(selector));
            } catch (error) {
                console.warn('Invalid selector:', selector, error);
                return [];
            }
        },

        _addListener(element, event, handler, options = {}) {
            if (!element || typeof handler !== 'function') return null;

            element.addEventListener(event, handler, options);
            return () => element.removeEventListener(event, handler, options);
        },

        // =============================================================================
        // PUBLIC API
        // =============================================================================

        // Get current endpoint data (for other components)
        getCurrentEndpoint() {
            return this.currentEndpoint;
        },

        // Check if sidebar is open (for other components)
        isSidebarOpen() {
            return this.isOpen;
        },

        // Get current active tab
        getCurrentTab() {
            const activeTab = this._safeQuery('.tester-tab.active');
            return activeTab ? activeTab.dataset.tab : null;
        },

        // Get current active response tab
        getCurrentResponseTab() {
            const activeTab = this._safeQuery('.response-tab.active');
            return activeTab ? activeTab.dataset.tab : null;
        },

        // Programmatically switch tabs
        switchTab(tabName) {
            this._switchTesterTab(tabName);
        },

        // Programmatically switch response tabs
        switchResponseTab(tabName) {
            this._switchResponseTab(tabName);
        },

        // Update response (for external use)
        updateResponse(responseData) {
            this._handleResponseReceived(responseData);
        },

        // Cleanup method
        destroy() {
            console.log('Destroying API Tester Sidebar...');

            // Clean up event listeners
            this._eventCleanup.forEach(cleanup => {
                try {
                    cleanup();
                } catch (error) {
                    console.warn('Error during event cleanup:', error);
                }
            });

            // Hide sidebar
            this._hideSidebar();

            // Reset state
            this.currentEndpoint = null;
            this.isOpen = false;
            this._eventCleanup = [];
            this.initialized = false;

            console.log('API Tester Sidebar destroyed');
        },

        // Send request using APIRequestHandler with auth mode
        async _sendRequest(authMode = 'guest') {
            if (!this.currentEndpoint) {
                console.error('No endpoint selected for request');
                return;
            }

            try {
                console.log(`Sending request for endpoint as ${authMode}:`, this.currentEndpoint.data);

                // Get auth token based on mode
                let authToken = null;
                if (authMode === 'admin') {
                    const adminAuth = localStorage.getItem('__pb_superuser_auth__');
                    if (adminAuth) {
                        const parsed = JSON.parse(adminAuth);
                        authToken = parsed.token;
                        console.log('Using admin token for request');
                    } else {
                        console.warn('No admin token found in localStorage');
                    }
                } else if (authMode === 'auth') {
                    const userAuth = localStorage.getItem('pocketbase_auth');
                    if (userAuth) {
                        const parsed = JSON.parse(userAuth);
                        authToken = parsed.token;
                        console.log('Using user token for request');
                    } else {
                        console.warn('No user token found in localStorage');
                    }
                }
                // guest mode uses no token (authToken stays null)

                // Use APIRequestHandler to send the request
                if (typeof APIRequestHandler !== 'undefined') {
                    await APIRequestHandler.sendRequest(this.currentEndpoint.data, authToken);
                } else {
                    console.error('APIRequestHandler not available');
                }
            } catch (error) {
                console.error('Failed to send request:', error);
            }
        },

        // Reset form using APIFormBuilder
        _resetForm() {
            if (!this.currentEndpoint) {
                console.error('No endpoint selected for reset');
                return;
            }

            try {
                // Clear form using APIFormBuilder
                if (typeof APIFormBuilder !== 'undefined') {
                    APIFormBuilder.clearForm();
                    console.log('Form reset successfully');
                } else {
                    // Fallback: manually clear form fields
                    const container = this._getElementById('schema-form-container');
                    if (container) {
                        const fields = container.querySelectorAll('.form-field');
                        fields.forEach(field => {
                            if (field.type === 'checkbox') {
                                field.checked = false;
                            } else {
                                field.value = '';
                            }
                        });
                    }
                }

                // Reset response display
                this._resetResponseDisplay();

            } catch (error) {
                console.error('Failed to reset form:', error);
            }
        },

        // Show validation errors to user
        _showValidationErrors(errors) {
            // You could implement a toast notification or highlight invalid fields
            // For now, just console log and alert
            const errorMessage = errors.join('\n');
            alert(`Please fix the following errors:\n\n${errorMessage}`);
        },

        // Reset response display
        _resetResponseDisplay() {
            // Show empty state
            const emptyState = this._getElementById('response-empty-state');
            const responseBody = this._getElementById('response-body');
            const responseHeaders = this._getElementById('response-headers');
            const copyBtn = this._getElementById('copy-response-btn');

            if (emptyState) emptyState.style.display = 'block';
            if (copyBtn) copyBtn.style.display = 'none';

            if (responseBody) {
                responseBody.style.display = 'none';
                responseBody.classList.remove('active');
                // Clear the content completely
                const bodyCode = responseBody.querySelector('code');
                if (bodyCode) bodyCode.textContent = '';
            }

            if (responseHeaders) {
                responseHeaders.style.display = 'none';
                responseHeaders.classList.remove('active');
                // Clear the content completely
                const headersCode = responseHeaders.querySelector('code');
                if (headersCode) headersCode.textContent = '';
            }

            // Reset response tabs to default (body)
            const responseTabs = this._safeQueryAll('.response-tab');
            responseTabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === 'body');
            });

            // Reset status
            this._updateResponseStatus('Ready', 'Send a request', 0);
        }
    };

    // Expose globally for endpoint renderer integration BEFORE auto-initialization
    window.APITesterSidebar = APITesterSidebar;
    window.APITester = APITesterSidebar; // Backward compatibility

    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => APITesterSidebar.init());
    } else {
        APITesterSidebar.init();
    }
{{end}}
