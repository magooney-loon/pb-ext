{{define "api_schema_processor_js"}}
    // =============================================================================
    // SCHEMA PROCESSING UTILITIES - ENHANCED WITH SYNTAX HIGHLIGHTING
    // =============================================================================

    const SchemaProcessor = {
        // Initialize syntax highlighting styles if not already present
        init() {
            if (!document.getElementById('syntax-highlighting-styles')) {
                const style = document.createElement('style');
                style.id = 'syntax-highlighting-styles';
                style.textContent = `
                    .json-key { color: #e91e63; font-weight: bold; }
                    .json-string { color: #4caf50; }
                    .json-number { color: #2196f3; }
                    .json-boolean { color: #ff9800; font-weight: bold; }
                    .json-null { color: #9e9e9e; font-style: italic; }
                    .yaml-key { color: #e91e63; font-weight: bold; }
                    .yaml-string { color: #4caf50; }
                    .yaml-number { color: #2196f3; }
                    .yaml-boolean { color: #ff9800; }
                    .yaml-comment { color: #757575; font-style: italic; }
                    .code-block {
                        background: #f5f5f5;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        padding: 12px;
                        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                        font-size: 13px;
                        line-height: 1.4;
                        overflow-x: auto;
                        white-space: pre;
                    }
                `;
                document.head.appendChild(style);
            }
        },

        // Enhanced JSON syntax highlighting
        syntaxHighlight(data, format = 'json') {
            this.init(); // Ensure styles are loaded

            if (!data) return '<span class="json-null">No data available</span>';

            let content;
            try {
                if (format === 'yaml') {
                    content = this.jsonToYaml(typeof data === 'string' ? JSON.parse(data) : data);
                    return this.highlightYaml(content);
                } else {
                    content = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
                    return this.highlightJson(content);
                }
            } catch (error) {
                console.warn('Failed to process data for highlighting:', error);
                return this.escapeHtml(String(data));
            }
        },

        // JSON syntax highlighting with improved regex
        highlightJson(jsonString) {
            return this.escapeHtml(jsonString)
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
                    (match) => {
                        let cls = 'number';
                        if (/^"/.test(match)) {
                            cls = /:$/.test(match) ? 'key' : 'string';
                        } else if (/true|false/.test(match)) {
                            cls = 'boolean';
                        } else if (/null/.test(match)) {
                            cls = 'null';
                        }
                        return `<span class="json-${cls}">${match}</span>`;
                    });
        },

        // YAML syntax highlighting
        highlightYaml(yamlString) {
            return this.escapeHtml(yamlString)
                .split('\n')
                .map(line => {
                    // Comments
                    if (line.trim().startsWith('#')) {
                        return `<span class="yaml-comment">${line}</span>`;
                    }

                    // Key-value pairs
                    return line.replace(/^(\s*)([^:\s]+)(\s*:\s*)(.*)$/, (match, indent, key, colon, value) => {
                        let highlightedValue = value;

                        // Highlight different value types
                        if (/^(true|false)$/.test(value.trim())) {
                            highlightedValue = `<span class="yaml-boolean">${value}</span>`;
                        } else if (/^-?\d+(\.\d+)?$/.test(value.trim())) {
                            highlightedValue = `<span class="yaml-number">${value}</span>`;
                        } else if (/^".*"$|^'.*'$/.test(value.trim())) {
                            highlightedValue = `<span class="yaml-string">${value}</span>`;
                        }

                        return `${indent}<span class="yaml-key">${key}</span>${colon}${highlightedValue}`;
                    });
                })
                .join('\n');
        },

        // Enhanced JSON to YAML conversion
        jsonToYaml(obj, indent = 0) {
            if (!obj) return 'No data available';
            if (typeof obj !== 'object') return String(obj);

            const spaces = '  '.repeat(indent);
            let yaml = '';

            try {
                if (Array.isArray(obj)) {
                    if (obj.length === 0) {
                        return '[]';
                    }
                    obj.forEach(item => {
                        if (typeof item === 'object' && item !== null) {
                            const itemYaml = this.jsonToYaml(item, indent + 1);
                            if (itemYaml.includes('\n')) {
                                yaml += `${spaces}-\n${itemYaml.split('\n').map(line => line ? `${spaces}  ${line}` : '').join('\n')}\n`;
                            } else {
                                yaml += `${spaces}- ${itemYaml}\n`;
                            }
                        } else {
                            yaml += `${spaces}- ${this.yamlValue(item)}\n`;
                        }
                    });
                } else {
                    for (const [key, value] of Object.entries(obj)) {
                        if (value === null) {
                            yaml += `${spaces}${key}: null\n`;
                        } else if (typeof value === 'object' && !Array.isArray(value)) {
                            yaml += `${spaces}${key}:\n${this.jsonToYaml(value, indent + 1)}`;
                        } else if (Array.isArray(value)) {
                            yaml += `${spaces}${key}:\n`;
                            if (value.length === 0) {
                                yaml += `${spaces}  []\n`;
                            } else {
                                value.forEach(item => {
                                    if (typeof item === 'object' && item !== null) {
                                        yaml += `${spaces}  -\n${this.jsonToYaml(item, indent + 2)}`;
                                    } else {
                                        yaml += `${spaces}  - ${this.yamlValue(item)}\n`;
                                    }
                                });
                            }
                        } else {
                            yaml += `${spaces}${key}: ${this.yamlValue(value)}\n`;
                        }
                    }
                }
            } catch (error) {
                console.error('YAML conversion error:', error);
                return 'Error converting to YAML format';
            }

            return yaml;
        },

        // Format value for YAML output
        yamlValue(value) {
            if (typeof value === 'string') {
                // Quote strings that contain special characters or look like other types
                if (/^(true|false|null|[0-9-+.]|[{}[\]])/.test(value) || value.includes(':') || value.includes('#')) {
                    return `"${value.replace(/"/g, '\\"')}"`;
                }
                return value;
            }
            return JSON.stringify(value);
        },

        // HTML escaping utility
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        // Calculate comprehensive endpoint statistics
        calculateStats(endpoints) {
            if (!Array.isArray(endpoints)) {
                console.warn('calculateStats expects an array of endpoints');
                return this.getEmptyStats();
            }

            const stats = {
                total_endpoints: endpoints.length,
                methods: {},
                auth_types: {},
                tags: {},
                status_codes: {},
                unique_paths: new Set(),
                auth_required_count: 0,
                paths_with_params: 0,
                deprecated_count: 0
            };

            endpoints.forEach(endpoint => {
                try {
                    // Count methods
                    const method = (endpoint.method || 'GET').toUpperCase();
                    stats.methods[method] = (stats.methods[method] || 0) + 1;

                    // Count auth types
                    if (endpoint.auth?.required) {
                        stats.auth_required_count++;
                        const authType = endpoint.auth.type || 'unknown';
                        stats.auth_types[authType] = (stats.auth_types[authType] || 0) + 1;
                    } else {
                        stats.auth_types['none'] = (stats.auth_types['none'] || 0) + 1;
                    }

                    // Count tags
                    if (endpoint.tags && Array.isArray(endpoint.tags)) {
                        endpoint.tags.forEach(tag => {
                            stats.tags[tag] = (stats.tags[tag] || 0) + 1;
                        });
                    }

                    // Count paths and analyze parameters
                    if (endpoint.path) {
                        stats.unique_paths.add(endpoint.path);
                        if (endpoint.path.includes('{') || endpoint.path.includes(':')) {
                            stats.paths_with_params++;
                        }
                    }

                    // Check for deprecated endpoints
                    if (endpoint.deprecated === true) {
                        stats.deprecated_count++;
                    }

                    // Analyze response status codes
                    if (endpoint.response && endpoint.response.status) {
                        const statusCode = endpoint.response.status;
                        stats.status_codes[statusCode] = (stats.status_codes[statusCode] || 0) + 1;
                    }

                } catch (error) {
                    console.warn('Error processing endpoint for stats:', error, endpoint);
                }
            });

            // Convert Set to count
            stats.unique_paths_count = stats.unique_paths.size;
            stats.total_tags = Object.keys(stats.tags).length;

            // Calculate percentages
            if (stats.total_endpoints > 0) {
                stats.auth_required_percentage = Math.round((stats.auth_required_count / stats.total_endpoints) * 100);
                stats.parameterized_percentage = Math.round((stats.paths_with_params / stats.total_endpoints) * 100);
            }

            return stats;
        },

        // Get empty stats structure
        getEmptyStats() {
            return {
                total_endpoints: 0,
                methods: {},
                auth_types: {},
                tags: {},
                status_codes: {},
                unique_paths_count: 0,
                auth_required_count: 0,
                paths_with_params: 0,
                deprecated_count: 0,
                total_tags: 0,
                auth_required_percentage: 0,
                parameterized_percentage: 0
            };
        },

        // Format data with syntax highlighting and proper structure
        formatForDisplay(data, format = 'json', containerElement = null) {
            if (!data) {
                return '<div class="code-block"><span class="json-null">No data available</span></div>';
            }

            const highlighted = this.syntaxHighlight(data, format);
            const formatted = `<div class="code-block">${highlighted}</div>`;

            if (containerElement) {
                containerElement.innerHTML = formatted;
            }

            return formatted;
        },

        // Update element with formatted content
        updateElement(elementId, data, format = 'json') {
            const element = document.getElementById(elementId);
            if (!element) {
                console.warn(`Element with id '${elementId}' not found`);
                return false;
            }

            try {
                this.formatForDisplay(data, format, element);
                return true;
            } catch (error) {
                console.error('Failed to update element with formatted content:', error);
                element.innerHTML = '<div class="code-block"><span class="json-null">Error formatting content</span></div>';
                return false;
            }
        },

        // Extract and format schema examples
        extractExamples(schema) {
            if (!schema || typeof schema !== 'object') {
                return null;
            }

            const examples = [];

            // OpenAPI 3.0 examples
            if (schema.examples) {
                Object.entries(schema.examples).forEach(([name, example]) => {
                    examples.push({
                        name: name,
                        value: example.value || example,
                        summary: example.summary || name,
                        description: example.description
                    });
                });
            }

            // OpenAPI 2.0 example
            if (schema.example) {
                examples.push({
                    name: 'Example',
                    value: schema.example,
                    summary: 'Example value'
                });
            }

            // JSON Schema examples
            if (schema.examples && Array.isArray(schema.examples)) {
                schema.examples.forEach((example, index) => {
                    examples.push({
                        name: `Example ${index + 1}`,
                        value: example,
                        summary: `Example ${index + 1}`
                    });
                });
            }

            return examples.length > 0 ? examples : null;
        },

        // Generate sample data from schema
        generateSampleFromSchema(schema) {
            if (!schema || typeof schema !== 'object') {
                return 'No schema available';
            }

            try {
                const sample = this._generateSampleValue(schema);
                return JSON.stringify(sample, null, 2);
            } catch (error) {
                console.warn('Failed to generate sample from schema:', error);
                return 'Unable to generate sample';
            }
        },

        // Internal method to generate sample values
        _generateSampleValue(schema) {
            if (!schema || typeof schema !== 'object') {
                return 'unknown';
            }

            // Use example if available
            if (schema.example !== undefined) {
                return schema.example;
            }

            // Handle different types
            switch (schema.type) {
                case 'string':
                    if (schema.enum) return schema.enum[0];
                    if (schema.format === 'date-time') return new Date().toISOString();
                    if (schema.format === 'date') return new Date().toISOString().split('T')[0];
                    if (schema.format === 'email') return 'user@example.com';
                    if (schema.format === 'uri') return 'https://example.com';
                    return schema.default || 'string';

                case 'number':
                case 'integer':
                    if (schema.enum) return schema.enum[0];
                    return schema.default !== undefined ? schema.default : 0;

                case 'boolean':
                    return schema.default !== undefined ? schema.default : true;

                case 'array':
                    if (schema.items) {
                        return [this._generateSampleValue(schema.items)];
                    }
                    return [];

                case 'object':
                    const obj = {};
                    if (schema.properties) {
                        Object.entries(schema.properties).forEach(([key, propSchema]) => {
                            obj[key] = this._generateSampleValue(propSchema);
                        });
                    }
                    return obj;

                default:
                    return schema.default !== undefined ? schema.default : null;
            }
        }
    };

    // Auto-initialize when script loads
    SchemaProcessor.init();

    // Make globally available
    window.SchemaProcessor = SchemaProcessor;
{{end}}
