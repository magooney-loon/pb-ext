{{define "api_tester_js"}}
    // =============================================================================
    // API TESTER - SCHEMA PROCESSING AND REQUEST HANDLING
    // =============================================================================

    const APITester = {
        currentEndpoint: null,
        schemaFields: {},
        debug: false,

        // Initialize the API tester
        init() {
            this.log('APITester initializing...');
            this.bindEvents();
            this.log('APITester initialized successfully');
        },

        // Debug logging
        log(...args) {
            if (this.debug) {
                console.log('[APITester]', ...args);
            }
        },

        // Bind event listeners
        bindEvents() {
            // Listen for sidebar events
            document.addEventListener('apiTesterSidebarOpened', (e) => {
                this.handleSidebarOpened(e.detail);
            });

            document.addEventListener('apiTesterSidebarClosed', () => {
                this.handleSidebarClosed();
            });

            document.addEventListener('apiTesterTabChange', (e) => {
                this.handleTabChange(e.detail);
            });

            // Form action buttons
            const sendBtn = document.getElementById('send-request-btn');
            const resetBtn = document.getElementById('reset-form-btn');

            if (sendBtn) {
                sendBtn.addEventListener('click', () => this.sendRequest());
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', () => this.resetForm());
            }
        },

        // Handle sidebar opened event
        handleSidebarOpened(detail) {
            this.log('Sidebar opened with endpoint:', detail);

            this.currentEndpoint = {
                method: detail.method,
                path: detail.path,
                data: detail.data || {}
            };

            // Validate endpoint using APIState if available
            if (typeof APIState !== 'undefined') {
                const validated = APIState.validateEndpoints([{
                    method: this.currentEndpoint.method,
                    path: this.currentEndpoint.path,
                    ...this.currentEndpoint.data
                }])[0];

                if (validated) {
                    this.currentEndpoint.data = validated;
                }
            }

            // Generate parameter form
            this.generateParameterForm();
        },

        // Handle sidebar closed event
        handleSidebarClosed() {
            this.log('Sidebar closed, cleaning up');
            this.currentEndpoint = null;
            this.schemaFields = {};
        },

        // Handle tab change event
        handleTabChange(detail) {
            if (detail.tab === 'response') {
                this.refreshResponseDisplay();
            }
        },

        // Generate parameter form using SchemaProcessor
        generateParameterForm() {
            const container = document.getElementById('schema-form-container');
            if (!container) return;

            // Show loading state
            container.innerHTML = `
                <div class="txt-center txt-hint p-4">
                    <i class="ri-loader-4-line animate-spin"></i>
                    <p>Processing schema...</p>
                </div>
            `;

            // Use SchemaProcessor if available
            if (typeof SchemaProcessor !== 'undefined' && this.currentEndpoint.data.request) {
                try {
                    const schema = this.currentEndpoint.data.request;
                    this.schemaFields = SchemaProcessor.extractParameters(schema) || [];

                    if (this.schemaFields.length > 0) {
                        const formHtml = this.buildFormFromSchema(this.schemaFields);
                        container.innerHTML = formHtml;
                        return;
                    }
                } catch (error) {
                    this.log('SchemaProcessor error:', error);
                    // Continue to path parameter extraction
                }
            }

            // Extract path parameters as fallback
            this.extractPathParameters(container);
        },

        // Extract path parameters from endpoint path
        extractPathParameters(container) {
            const pathParams = [];
            const pathMatches = this.currentEndpoint.path.match(/{([^}]+)}/g);

            if (pathMatches) {
                pathMatches.forEach(match => {
                    const paramName = match.replace(/[{}]/g, '');
                    pathParams.push({
                        name: paramName,
                        type: 'string',
                        required: true,
                        description: `Path parameter: ${paramName}`
                    });
                });
            }

            // Add query parameters for GET requests
            if (this.currentEndpoint.method === 'GET') {
                pathParams.push({
                    name: 'limit',
                    type: 'integer',
                    required: false,
                    description: 'Number of records to return'
                }, {
                    name: 'offset',
                    type: 'integer',
                    required: false,
                    description: 'Number of records to skip'
                });
            }

            if (pathParams.length > 0) {
                this.schemaFields = pathParams;
                container.innerHTML = this.buildFormFromSchema(this.schemaFields);
            } else {
                this.generateFallbackForm(container);
            }
        },

        // Build form HTML from schema fields
        buildFormFromSchema(fields) {
            if (!fields.length) {
                return `
                    <div class="txt-center txt-hint p-3">
                        <i class="ri-info-line"></i>
                        <p>No parameters required for this endpoint</p>
                    </div>
                `;
            }

            const fieldGroups = this.groupFields(fields);
            let html = '';

            Object.entries(fieldGroups).forEach(([group, groupFields]) => {
                if (group !== 'default') {
                    html += `<div class="form-group">
                        <h6 class="form-group-title">${group}</h6>
                    `;
                }

                groupFields.forEach(field => {
                    html += `
                        <div class="form-field">
                            <label class="form-label">
                                ${field.name}
                                ${field.required ? '<span class="txt-danger">*</span>' : ''}
                                <span class="txt-hint txt-xs">(${field.type})</span>
                            </label>
                            ${this.buildFieldInput(field)}
                            ${field.description ? `<div class="help-block">${field.description}</div>` : ''}
                        </div>
                    `;
                });

                if (group !== 'default') {
                    html += '</div>';
                }
            });

            return html;
        },

        // Group fields by category
        groupFields(fields) {
            const groups = { default: [] };

            fields.forEach(field => {
                if (field.name.includes('_')) {
                    const prefix = field.name.split('_')[0];
                    if (!groups[prefix]) groups[prefix] = [];
                    groups[prefix].push(field);
                } else {
                    groups.default.push(field);
                }
            });

            return groups;
        },

        // Build input field based on field type
        buildFieldInput(field) {
            const baseAttrs = `name="${field.name}" id="field-${field.name}"`;
            const requiredAttr = field.required ? 'required' : '';
            const placeholder = field.example ? `placeholder="${field.example}"` : '';

            switch (field.type) {
                case 'boolean':
                    return `
                        <select class="form-control" ${baseAttrs} ${requiredAttr}>
                            <option value="">Select...</option>
                            <option value="true">true</option>
                            <option value="false">false</option>
                        </select>
                    `;

                case 'integer':
                case 'number':
                    return `
                        <input type="number" class="form-control" ${baseAttrs} ${requiredAttr} ${placeholder}
                            ${field.type === 'integer' ? 'step="1"' : 'step="any"'} />
                    `;

                case 'array':
                    return `
                        <textarea class="form-control" ${baseAttrs} ${requiredAttr}
                            placeholder="Enter JSON array or comma-separated values" rows="3"></textarea>
                        <small class="form-text">Format: ["item1", "item2"] or item1, item2, item3</small>
                    `;

                case 'object':
                    return `
                        <textarea class="form-control" ${baseAttrs} ${requiredAttr}
                            placeholder="Enter JSON object" rows="4"></textarea>
                        <small class="form-text">Format: {"key": "value"}</small>
                    `;

                case 'string':
                    if (field.enum && field.enum.length > 0) {
                        const options = field.enum.map(value =>
                            `<option value="${value}">${value}</option>`
                        ).join('');
                        return `
                            <select class="form-control" ${baseAttrs} ${requiredAttr}>
                                <option value="">Select...</option>
                                ${options}
                            </select>
                        `;
                    }
                    return `<input type="text" class="form-control" ${baseAttrs} ${requiredAttr} ${placeholder} />`;

                default:
                    return `<input type="text" class="form-control" ${baseAttrs} ${requiredAttr} ${placeholder} />`;
            }
        },

        // Generate fallback form for manual input
        generateFallbackForm(container) {
            const isPostPutPatch = ['POST', 'PUT', 'PATCH'].includes(this.currentEndpoint.method);

            container.innerHTML = `
                <div class="txt-center txt-hint p-3 mb-3">
                    <i class="ri-settings-3-line"></i>
                    <p>No schema available</p>
                    <p class="txt-xs">Manual parameter entry</p>
                </div>

                ${isPostPutPatch ? `
                    <div class="form-field">
                        <label class="form-label">Request Body (JSON)</label>
                        <textarea class="form-control" name="request-body"
                            placeholder="Enter JSON request body" rows="8"></textarea>
                        <small class="form-text">Enter the complete JSON payload for this ${this.currentEndpoint.method} request</small>
                    </div>
                ` : `
                    <div class="form-field">
                        <label class="form-label">Query Parameters</label>
                        <textarea class="form-control" name="query-params"
                            placeholder="param1=value1&param2=value2" rows="3"></textarea>
                        <small class="form-text">Enter query parameters in URL format</small>
                    </div>
                `}
            `;
        },

        // Send HTTP request
        async sendRequest() {
            if (!this.currentEndpoint) return;

            this.log('Sending request...');

            const sendBtn = document.getElementById('send-request-btn');
            const originalText = sendBtn.innerHTML;

            try {
                // Update button state
                sendBtn.innerHTML = '<i class="ri-loader-4-line animate-spin"></i> Sending...';
                sendBtn.disabled = true;

                // Collect and validate form data
                const requestData = this.collectFormData();

                // Make the HTTP request
                const response = await this.makeRequest(requestData);

                // Display response
                this.displayResponse(response);

                // Switch to response tab via sidebar
                if (typeof APITesterSidebar !== 'undefined') {
                    APITesterSidebar.switchTesterTab('response');
                }

            } catch (error) {
                this.log('Request error:', error);
                this.displayError(error);

                if (typeof APITesterSidebar !== 'undefined') {
                    APITesterSidebar.switchTesterTab('response');
                }
            } finally {
                // Restore button state
                sendBtn.innerHTML = originalText;
                sendBtn.disabled = false;
            }
        },

        // Collect and validate form data
        collectFormData() {
            const formData = {};
            const container = document.getElementById('schema-form-container');

            if (!container) return formData;

            const inputs = container.querySelectorAll('input, select, textarea');

            inputs.forEach(input => {
                const value = input.value.trim();
                if (value) {
                    const field = this.schemaFields.find(f => f.name === input.name);
                    formData[input.name] = this.convertValue(value, field);
                }
            });

            // Validate required fields
            this.validateFormData(formData);

            this.log('Collected form data:', formData);
            return formData;
        },

        // Convert form value based on field type
        convertValue(value, field) {
            if (!field) return value;

            try {
                switch (field.type) {
                    case 'integer':
                        const intValue = parseInt(value, 10);
                        if (isNaN(intValue)) throw new Error(`Invalid integer: ${value}`);
                        return intValue;

                    case 'number':
                        const numValue = parseFloat(value);
                        if (isNaN(numValue)) throw new Error(`Invalid number: ${value}`);
                        return numValue;

                    case 'boolean':
                        return value === 'true';

                    case 'array':
                        if (value.startsWith('[')) {
                            return JSON.parse(value);
                        }
                        return value.split(',').map(v => v.trim()).filter(v => v);

                    case 'object':
                        return JSON.parse(value);

                    default:
                        return value;
                }
            } catch (error) {
                this.log(`Type conversion error for ${field.name}:`, error);
                throw new Error(`Invalid ${field.type} value for ${field.name}: ${error.message}`);
            }
        },

        // Validate form data
        validateFormData(formData) {
            const missingRequired = this.schemaFields
                .filter(field => field.required && !(field.name in formData))
                .map(field => field.name);

            if (missingRequired.length > 0) {
                throw new Error(`Missing required fields: ${missingRequired.join(', ')}`);
            }
        },

        // Make HTTP request
        async makeRequest(data) {
            let url = this.currentEndpoint.path;
            const method = this.currentEndpoint.method;
            let bodyData = { ...data };

            // Replace path parameters in URL
            Object.keys(data).forEach(key => {
                const placeholder = `{${key}}`;
                if (url.includes(placeholder)) {
                    url = url.replace(placeholder, encodeURIComponent(data[key]));
                    delete bodyData[key];
                }
            });

            // Build full URL
            const baseUrl = window.location.origin;
            const fullUrl = url.startsWith('http') ? url : baseUrl + url;

            const options = {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json, text/plain, */*'
                }
            };

            // Add authentication if required
            if (this.currentEndpoint.data.auth?.required) {
                // This could be extended to handle different auth types
                this.log('Auth required - extend this for your auth mechanism');
            }

            // Handle request body/query params based on method
            if (['POST', 'PUT', 'PATCH'].includes(method)) {
                if (Object.keys(bodyData).length > 0) {
                    options.body = JSON.stringify(bodyData);
                }
            } else if (['GET', 'DELETE'].includes(method)) {
                if (Object.keys(bodyData).length > 0) {
                    const params = new URLSearchParams();
                    Object.entries(bodyData).forEach(([key, value]) => {
                        if (value !== null && value !== undefined) {
                            params.append(key, String(value));
                        }
                    });
                    if (params.toString()) {
                        url += (url.includes('?') ? '&' : '?') + params.toString();
                    }
                }
            }

            const startTime = Date.now();

            try {
                this.log('Making request to:', url, 'with options:', options);

                const response = await fetch(url, options);
                const endTime = Date.now();

                const responseData = {
                    status: response.status,
                    statusText: response.statusText,
                    headers: Object.fromEntries(response.headers.entries()),
                    body: await response.text(),
                    time: endTime - startTime,
                    url: url
                };

                this.log('Request completed:', {
                    status: response.status,
                    time: responseData.time
                });

                return responseData;

            } catch (error) {
                const endTime = Date.now();
                this.log('Request failed:', error);

                throw {
                    message: `Network error: ${error.message}`,
                    time: endTime - startTime,
                    url: url
                };
            }
        },

        // Display successful response
        displayResponse(response) {
            if (typeof APITesterSidebar !== 'undefined') {
                APITesterSidebar.updateResponseStatus(response.status, response.statusText, response.time);
                APITesterSidebar.updateResponseContent(response.body, response.headers);
                APITesterSidebar.showResponseContent();
            }
        },

        // Display error response
        displayError(error) {
            const errorResponse = {
                error: {
                    message: error.message || 'Unknown error',
                    type: 'RequestError',
                    timestamp: new Date().toISOString(),
                    url: error.url
                }
            };

            if (typeof APITesterSidebar !== 'undefined') {
                APITesterSidebar.updateResponseStatus('Error', error.message || 'Request failed', error.time || 0);
                APITesterSidebar.updateResponseContent(JSON.stringify(errorResponse, null, 2), {
                    'content-type': 'application/json',
                    'x-error': 'true'
                });
                APITesterSidebar.showResponseContent();
            }

            // Use ErrorHandler if available
            if (typeof ErrorHandler !== 'undefined') {
                ErrorHandler.logError('API Tester Request Failed', error);
            }
        },

        // Reset form to default values
        resetForm() {
            const container = document.getElementById('schema-form-container');
            if (!container) return;

            const inputs = container.querySelectorAll('input, select, textarea');
            inputs.forEach(input => {
                if (input.type === 'checkbox' || input.type === 'radio') {
                    input.checked = false;
                } else {
                    input.value = '';
                }
            });

            this.log('Form reset');
        },

        // Refresh response display when switching to response tab
        refreshResponseDisplay() {
            // Check if we have response content to display
            const emptyState = document.getElementById('response-empty-state');
            const hasContent = emptyState && emptyState.style.display === 'none';

            if (hasContent) {
                this.log('Response content already displayed');
            } else {
                this.log('No response content to display');
            }
        },

        // Public API for opening sidebar (for endpoint renderer integration)
        openSidebar(method, path, endpointData) {
            if (typeof APITesterSidebar !== 'undefined') {
                APITesterSidebar.openSidebar(method, path, endpointData);
            } else {
                console.warn('APITesterSidebar not available');
            }
        }
    };
{{end}}
