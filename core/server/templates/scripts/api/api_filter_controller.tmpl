{{define "api_filter_controller_js"}}
    // =============================================================================
    // UI CONTROLLERS - FILTER MANAGEMENT
    // =============================================================================

    const FilterController = {
        init() {
            const searchInput = document.getElementById('search-input');
            const methodFilter = document.getElementById('method-filter');
            const authFilter = document.getElementById('auth-filter');
            const tagFilter = document.getElementById('tag-filter');
            const clearBtn = document.getElementById('clear-filters-btn');

            if (searchInput) {
                searchInput.addEventListener('input', this.debounce(() => this.applyFilters(), 300));
            }

            [methodFilter, authFilter, tagFilter].forEach(filter => {
                if (filter) {
                    filter.addEventListener('change', () => this.applyFilters());
                }
            });

            if (clearBtn) {
                clearBtn.addEventListener('click', () => this.clearFilters());
            }
        },

        applyFilters() {
            const searchTerm = document.getElementById('search-input')?.value.toLowerCase() || '';
            const methodValue = document.getElementById('method-filter')?.value || '';
            const authValue = document.getElementById('auth-filter')?.value || '';
            const tagValue = document.getElementById('tag-filter')?.value || '';

            APIState.filteredEndpoints = APIState.allEndpoints.filter(endpoint => {
                const matchesSearch = !searchTerm || this.matchesSearchTerm(endpoint, searchTerm);
                const matchesMethod = !methodValue || endpoint.method.toLowerCase() === methodValue.toLowerCase();
                const matchesAuth = this.matchesAuth(endpoint, authValue);
                const matchesTag = !tagValue || endpoint.tags?.includes(tagValue);

                return matchesSearch && matchesMethod && matchesAuth && matchesTag;
            });

            EndpointRenderer.render();
            this.updateFilterSummary();
            this.updateActiveFilters();
        },

        matchesSearchTerm(endpoint, term) {
            const searchableFields = [
                endpoint.path,
                endpoint.description,
                endpoint.handler_name,
                ...(endpoint.tags || [])
            ];

            return searchableFields.some(field =>
                field?.toLowerCase().includes(term));
        },

        matchesAuth(endpoint, authValue) {
            if (!authValue) return true;

            if (authValue === 'required') return endpoint.auth?.required;
            if (authValue === 'none') return !endpoint.auth?.required;

            return endpoint.auth?.type === authValue;
        },

        clearFilters() {
            ['search-input', 'method-filter', 'auth-filter', 'tag-filter'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = '';
            });

            APIState.filteredEndpoints = [...APIState.allEndpoints];
            EndpointRenderer.render();
            this.updateFilterSummary();
            this.updateActiveFilters();
        },

        updateFilterSummary() {
            const filteredCountSpan = document.getElementById('filtered-count');
            const totalCountSpan = document.getElementById('total-count');
            const summaryDiv = document.getElementById('results-summary');

            if (filteredCountSpan) filteredCountSpan.textContent = APIState.filteredEndpoints.length;
            if (totalCountSpan) totalCountSpan.textContent = APIState.allEndpoints.length;
            if (summaryDiv) summaryDiv.style.display = APIState.allEndpoints.length > 0 ? 'block' : 'none';
        },

        updateActiveFilters() {
            const activeFiltersDiv = document.getElementById('active-filters');
            const filterTagsDiv = document.getElementById('filter-tags');

            if (!activeFiltersDiv || !filterTagsDiv) return;

            const filters = [];
            const searchValue = document.getElementById('search-input')?.value;
            const methodValue = document.getElementById('method-filter')?.value;
            const authValue = document.getElementById('auth-filter')?.value;
            const tagValue = document.getElementById('tag-filter')?.value;

            if (searchValue) filters.push({ type: 'search', value: searchValue, label: `Search: "${searchValue}"` });
            if (methodValue) filters.push({ type: 'method', value: methodValue, label: `Method: ${methodValue.toUpperCase()}` });
            if (authValue) filters.push({ type: 'auth', value: authValue, label: `Auth: ${authValue.replace(/_/g, ' ')}` });
            if (tagValue) filters.push({ type: 'tag', value: tagValue, label: `Tag: ${tagValue}` });

            if (filters.length > 0) {
                activeFiltersDiv.style.display = 'block';
                filterTagsDiv.innerHTML = filters.map(filter => `
                    <span class="badge badge-sm badge-secondary">
                        ${filter.label}
                        <i class="ri-close-line cursor-pointer ml-1" onclick="FilterController.clearFilter('${filter.type}')"></i>
                    </span>
                `).join('');
            } else {
                activeFiltersDiv.style.display = 'none';
            }
        },

        clearFilter(type) {
            const elementId = {
                'search': 'search-input',
                'method': 'method-filter',
                'auth': 'auth-filter',
                'tag': 'tag-filter'
            }[type];

            if (elementId) {
                const element = document.getElementById(elementId);
                if (element) element.value = '';
                this.applyFilters();
            }
        },

        populateFilterOptions(stats) {
            this.populateMethodOptions(stats.methods);
            this.populateAuthOptions(stats.auth_types);
            this.populateTagOptions(stats.tags);
        },

        populateMethodOptions(methods) {
            const select = document.getElementById('method-filter');
            if (!select) return;

            // Clear existing options except first
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            Object.entries(methods).sort(([,a], [,b]) => b - a).forEach(([method, count]) => {
                const option = document.createElement('option');
                option.value = method.toLowerCase();
                option.textContent = `${method} (${count})`;
                select.appendChild(option);
            });
        },

        populateAuthOptions(authTypes) {
            const select = document.getElementById('auth-filter');
            if (!select) return;

            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            const authLabels = {
                'none': 'No Auth Required',
                'required': 'Auth Required',
                'superuser': 'Superuser Only',
                'user': 'User Auth',
                'guest_only': 'Guest Only'
            };

            Object.entries(authTypes).sort(([,a], [,b]) => b - a).forEach(([authType, count]) => {
                const option = document.createElement('option');
                option.value = authType;
                option.textContent = `${authLabels[authType] || authType} (${count})`;
                select.appendChild(option);
            });
        },

        populateTagOptions(tags) {
            const select = document.getElementById('tag-filter');
            if (!select || !Object.keys(tags).length) return;

            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            Object.entries(tags).sort(([,a], [,b]) => b - a).forEach(([tag, count]) => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = `${tag} (${count})`;
                select.appendChild(option);
            });
        },

        debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    };
{{end}}
