{{define "api_loader_js"}}
    // =============================================================================
    // SIMPLIFIED API LOADER - FOR CLEAN OPENAPI BACKEND
    // =============================================================================

    const APILoader = {
        loadingState: {
            versions: false,
            endpoints: false
        },

        // Get superuser authentication token from localStorage
        getSuperuserAuthToken() {
            try {
                console.log('üîë Checking for superuser auth token in localStorage...');
                const authData = localStorage.getItem('__pb_superuser_auth__');
                if (!authData) {
                    console.warn('‚ùå No superuser authentication token found in localStorage');
                    console.log('üìã Available localStorage keys:', Object.keys(localStorage));
                    return null;
                }

                console.log('‚úÖ Found auth data in localStorage, parsing...');
                const parsed = JSON.parse(authData);
                const token = parsed.token || null;
                console.log('üé´ Parsed token:', token ? `${token.substring(0, 20)}...` : 'null');
                return token;
            } catch (error) {
                console.error('‚ùå Failed to parse superuser auth token:', error);
                return null;
            }
        },

        // Create authenticated fetch options
        getAuthenticatedFetchOptions(options = {}) {
            const token = this.getSuperuserAuthToken();
            if (!token) {
                throw new Error('SuperUser authentication required');
            }

            return {
                ...options,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            };
        },

        // Load available API versions
        async loadVersions() {
            if (this.loadingState.versions) {
                console.log('Versions already loading, skipping duplicate request');
                return;
            }

            this.loadingState.versions = true;

            try {
                this.updateStatus('loading', 'Loading API versions...');

                const response = await fetch('/api/docs/versions', this.getAuthenticatedFetchOptions());
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('SuperUser authentication required. Please log in as superuser.');
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                console.log('üìä Parsing response data...');
                const data = await response.json();
                console.log('üìÑ Response data structure:', {
                    hasVersions: !!data.versions,
                    versionsLength: data.versions?.length,
                    defaultVersion: data.default_version,
                    dataKeys: Object.keys(data || {})
                });

                if (!data || !data.versions) {
                    console.error('‚ùå Invalid response format:', data);
                    throw new Error('Invalid response format from versions endpoint');
                }

                // Store version information
                console.log('üíæ Storing version information in APIState...');
                APIState.availableVersions = data.versions;
                APIState.currentVersion = data.default_version || (data.versions.length > 0 ? data.versions[0].version : null);

                console.log(`‚úÖ Loaded ${data.versions.length} API versions, default: ${APIState.currentVersion}`);
                console.log('üìã Available versions:', data.versions.map(v => v.version));

                // Update UI
                console.log('üé® Populating version selector...');
                this.populateVersionSelector();

                // Load the current version's endpoints
                if (APIState.currentVersion) {
                    console.log(`üîÑ Loading endpoints for version: ${APIState.currentVersion}`);
                    await this.loadEndpoints();
                } else {
                    console.error('‚ùå No current version set');
                    throw new Error('No API versions available');
                }

            } catch (error) {
                console.error('‚ùå Failed to load API versions:', error);
                console.error('üìç Error stack:', error.stack);
                this.updateStatus('error', `Failed to load API versions: ${error.message}`);
                throw error;
            } finally {
                console.log('üèÅ Finished loadVersions(), resetting loading state');
                this.loadingState.versions = false;
            }
        },

        // Load OpenAPI spec for current version
        async loadEndpoints() {
            if (this.loadingState.endpoints) {
                console.log('Endpoints already loading, skipping duplicate request');
                return;
            }

            this.loadingState.endpoints = true;

            try {
                const version = APIState.currentVersion;
                if (!version) {
                    throw new Error('No current version selected');
                }

                this.updateStatus('loading', `Loading endpoints for version ${version}...`);

                const response = await fetch(`/api/docs/${version}`, this.getAuthenticatedFetchOptions());
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('SuperUser authentication required. Please log in as superuser.');
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                console.log('üìä Parsing endpoints response data...');
                const openApiSpec = await response.json();
                console.log('üìÑ OpenAPI spec structure:', {
                    hasEndpoints: !!openApiSpec.endpoints,
                    endpointsLength: openApiSpec.endpoints?.length,
                    specKeys: Object.keys(openApiSpec || {})
                });

                if (!openApiSpec || !openApiSpec.endpoints) {
                    console.error('‚ùå Invalid OpenAPI specification:', openApiSpec);
                    throw new Error('Invalid OpenAPI specification received');
                }

                // Store the clean OpenAPI data - no conversion needed!
                console.log('üíæ Storing OpenAPI data in APIState...');
                APIState.openApiSchema = openApiSpec;
                APIState.allEndpoints = openApiSpec.endpoints;
                APIState.setEndpoints(openApiSpec.endpoints);

                console.log(`‚úÖ Loaded ${openApiSpec.endpoints.length} endpoints for version ${version}`);

                // Update UI
                this.updateEndpointsList();
                this.updateStatsDisplay();
                this.updateVersionDisplay();
                this.initializeFilters();

                this.updateStatus('success', `Loaded ${openApiSpec.endpoints.length} endpoints`);

            } catch (error) {
                console.error('Failed to load endpoints:', error);
                this.updateStatus('error', `Failed to load endpoints: ${error.message}`);
                throw error;
            } finally {
                this.loadingState.endpoints = false;
            }
        },

        // Switch to different API version
        async switchVersion(newVersion) {
            if (newVersion === APIState.currentVersion) {
                console.log(`Already on version ${newVersion}`);
                return;
            }

            console.log(`Switching from ${APIState.currentVersion} to ${newVersion}`);
            APIState.currentVersion = newVersion;

            // Clear current data
            APIState.allEndpoints = [];
            APIState.filteredEndpoints = [];
            APIState.openApiSchema = null;

            // Load new version
            await this.loadEndpoints();
        },

        // Populate version selector dropdown
        populateVersionSelector() {
            const versionSelect = document.getElementById('version-select');
            if (!versionSelect || !APIState.availableVersions.length) {
                return;
            }

            versionSelect.innerHTML = '';

            APIState.availableVersions.forEach(versionInfo => {
                const option = document.createElement('option');
                option.value = versionInfo.version;

                const config = versionInfo.config || {};
                const title = config.title || 'API';
                const version = config.version || versionInfo.version;
                const status = versionInfo.status || 'stable';
                const statusIcon = this.getStatusIcon(status);

                option.textContent = `${title} ${version} ${statusIcon}`;
                option.selected = versionInfo.version === APIState.currentVersion;
                versionSelect.appendChild(option);
            });

            // Add change event listener
            versionSelect.removeEventListener('change', this.handleVersionChange);
            versionSelect.addEventListener('change', this.handleVersionChange.bind(this));
        },

        // Handle version selection change
        async handleVersionChange(event) {
            const newVersion = event.target.value;
            if (newVersion && newVersion !== APIState.currentVersion) {
                try {
                    await this.switchVersion(newVersion);
                } catch (error) {
                    console.error('Failed to switch version:', error);
                    // Revert selection on error
                    event.target.value = APIState.currentVersion;
                }
            }
        },

        // Update endpoints list in UI
        updateEndpointsList() {
            console.log('üé® updateEndpointsList() called');
            if (typeof EndpointRenderer !== 'undefined' && EndpointRenderer.render) {
                console.log('‚úÖ EndpointRenderer available, calling render...');
                EndpointRenderer.render();
                console.log('üèÅ EndpointRenderer.render() completed');
            } else {
                console.error('‚ùå EndpointRenderer or render method not available:', {
                    EndpointRenderer: typeof EndpointRenderer,
                    render: typeof EndpointRenderer?.render
                });
            }
        },

        // Update statistics display
        updateStatsDisplay() {
            console.log('üìä updateStatsDisplay() called');
            const stats = this.calculateStats();
            console.log('üìà Calculated stats:', stats);
            APIState.apiStats = stats;

            if (typeof UIController !== 'undefined' && UIController.updateStatistics) {
                console.log('‚úÖ UIController available, calling updateStatistics...');
                UIController.updateStatistics(stats);
                console.log('üèÅ updateStatistics() completed');
            } else {
                console.error('‚ùå UIController or updateStatistics not available:', {
                    UIController: typeof UIController,
                    updateStatistics: typeof UIController?.updateStatistics
                });
            }
        },

        // Update version display information
        updateVersionDisplay() {
            console.log('üè∑Ô∏è updateVersionDisplay() called');
            const versionInfo = APIState.availableVersions.find(v => v.version === APIState.currentVersion);
            console.log('üìã Version info found:', versionInfo);
            if (!versionInfo) {
                console.warn('‚ö†Ô∏è No version info found for current version:', APIState.currentVersion);
                return;
            }

            // Update version info display
            const versionInfoEl = document.getElementById('version-info');
            console.log('üéØ Version info element:', versionInfoEl);
            if (versionInfoEl && versionInfo.config) {
                console.log('‚úÖ Updating version info display...');
                const config = versionInfo.config;
                versionInfoEl.innerHTML = `
                    <h3>${config.title || 'API'} ${config.version || versionInfo.version}</h3>
                    <p>${config.description || 'No description available'}</p>
                    <span class="status-badge status-${versionInfo.status || 'stable'}">${versionInfo.status || 'stable'}</span>
                `;
                console.log('üèÅ Version display updated');
            } else {
                console.warn('‚ö†Ô∏è Version info element not found or no config available');
            }
        },

        // Initialize filter options
        initializeFilters() {
            console.log('üîß initializeFilters() called');
            if (typeof UIController !== 'undefined') {
                console.log('‚úÖ UIController available, initializing filters...');
                const stats = APIState.apiStats || this.calculateStats();
                console.log('üìà Using stats for filters:', stats);
                if (UIController.populateFilterOptions) {
                    console.log('üîÑ Calling populateFilterOptions...');
                    UIController.populateFilterOptions(stats);
                    console.log('‚úÖ populateFilterOptions completed');
                }

                // Show filters section
                const filtersSection = document.getElementById('api-filters');
                console.log('üéØ Filters section element:', filtersSection);
                if (filtersSection) {
                    filtersSection.style.display = 'block';
                    console.log('‚úÖ Filters section shown');
                } else {
                    console.warn('‚ö†Ô∏è Filters section element not found');
                }
            } else {
                console.error('‚ùå UIController not available for filter initialization');
            }
        },

        // Calculate statistics from endpoints
        calculateStats() {
            const endpoints = APIState.allEndpoints || [];

            const stats = {
                totalEndpoints: endpoints.length,
                methods: {},
                tags: {},
                authTypes: {}
            };

            endpoints.forEach(endpoint => {
                // Count methods
                const method = endpoint.method || 'UNKNOWN';
                stats.methods[method] = (stats.methods[method] || 0) + 1;

                // Count tags
                (endpoint.tags || []).forEach(tag => {
                    stats.tags[tag] = (stats.tags[tag] || 0) + 1;
                });

                // Count auth types
                const authType = endpoint.auth?.type || 'none';
                stats.authTypes[authType] = (stats.authTypes[authType] || 0) + 1;
            });

            return stats;
        },

        // Get status icon for version status
        getStatusIcon(status) {
            const icons = {
                'stable': '‚úÖ',
                'testing': 'üß™',
                'beta': 'üî¨',
                'deprecated': '‚ö†Ô∏è',
                'maintenance': 'üîß'
            };
            return icons[status] || 'üìã';
        },

        // Update status message
        updateStatus(type, message) {
            if (typeof ErrorStatusManager !== 'undefined') {
                ErrorStatusManager.updateStatus(type, message);
            } else if (typeof StatusManager !== 'undefined') {
                StatusManager.updateStatus(type, message);
            } else {
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        },

        // Check if currently loading
        isLoading() {
            return this.loadingState.versions || this.loadingState.endpoints;
        },

        // Initialize the API loader
        async initialize() {
            try {
                await this.loadVersions();
                return true;
            } catch (error) {
                console.error('Failed to initialize API loader:', error);
                return false;
            }
        },

        // DEBUG METHODS FOR TROUBLESHOOTING
        getDebugInfo() {
            return {
                timestamp: new Date().toISOString(),
                loading: {
                    versions: this.loadingState.versions,
                    endpoints: this.loadingState.endpoints
                },
                auth: {
                    hasToken: !!this.getSuperuserAuthToken(),
                    tokenPreview: this.getSuperuserAuthToken()?.substring(0, 20) + '...' || null
                },
                state: {
                    availableVersions: APIState.availableVersions?.length || 0,
                    currentVersion: APIState.currentVersion,
                    allEndpoints: APIState.allEndpoints?.length || 0,
                    filteredEndpoints: APIState.filteredEndpoints?.length || 0
                },
                components: {
                    APIState: typeof APIState,
                    UIController: typeof UIController,
                    EndpointRenderer: typeof EndpointRenderer,
                    ErrorStatusManager: typeof ErrorStatusManager
                },
                dom: {
                    versionSelect: !!document.getElementById('version-select'),
                    endpointsList: !!document.getElementById('endpoints-list'),
                    apiFilters: !!document.getElementById('api-filters')
                }
            };
        },

        async testConnection() {
            console.log('üß™ Testing API connection...');
            try {
                const response = await fetch('/api/docs/versions', this.getFetchOptions(false));
                console.log('‚úÖ Connection test successful:', response.status, response.statusText);
                const data = await response.json();
                console.log('üìä Response data:', data);
                return { success: true, status: response.status, data };
            } catch (error) {
                console.error('‚ùå Connection test failed:', error);
                return { success: false, error: error.message };
            }
        },

        async forceReload() {
            console.log('üîÑ Force reloading API data...');
            this.loadingState.versions = false;
            this.loadingState.endpoints = false;
            APIState.reset();
            return await this.initialize();
        },

        checkDependencies() {
            const deps = {
                APIState: typeof APIState !== 'undefined',
                UIController: typeof UIController !== 'undefined',
                EndpointRenderer: typeof EndpointRenderer !== 'undefined',
                ErrorStatusManager: typeof ErrorStatusManager !== 'undefined'
            };

            console.log('üîç Dependency check:', deps);
            const missing = Object.entries(deps).filter(([name, available]) => !available);

            if (missing.length > 0) {
                console.error('‚ùå Missing dependencies:', missing.map(([name]) => name));
                return { success: false, missing: missing.map(([name]) => name) };
            } else {
                console.log('‚úÖ All dependencies available');
                return { success: true };
            }
        }
    };

    // Export for global use
    if (typeof window !== 'undefined') {
        window.APILoader = APILoader;

        // Global debug helper for troubleshooting
        window.APIDebug = window.APIDebug || {};
        window.APIDebug.loader = {
            // Quick status check
            status: () => APILoader.getDebugInfo(),

            // Test API connection
            test: () => APILoader.testConnection(),

            // Force reload API data
            reload: () => APILoader.forceReload(),

            // Check component dependencies
            deps: () => APILoader.checkDependencies(),

            // Get auth token info
            auth: () => ({
                hasToken: !!APILoader.getSuperuserAuthToken(),
                tokenPreview: APILoader.getSuperuserAuthToken()?.substring(0, 20) + '...' || null
            }),

            // Manual initialization
            init: () => APILoader.initialize(),

            // Current state snapshot
            state: () => ({
                versions: APIState?.availableVersions || [],
                currentVersion: APIState?.currentVersion,
                endpoints: APIState?.allEndpoints?.length || 0,
                filtered: APIState?.filteredEndpoints?.length || 0
            })
        };

        console.log('üîß Debug helper available: window.APIDebug.loader');
        console.log('üí° Try: APIDebug.loader.status() or APIDebug.loader.test()');
    }

{{end}}
