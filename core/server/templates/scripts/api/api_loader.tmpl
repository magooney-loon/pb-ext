{{define "api_loader_js"}}
    // =============================================================================
    // DATA LOADING AND INITIALIZATION
    // =============================================================================

    const APILoader = {
        loadingState: {
            versions: false,
            schema: false,
            config: false
        },

        async loadVersions() {
            if (this.loadingState.versions) {
                console.log('Versions already loading, skipping duplicate request');
                return;
            }

            this.loadingState.versions = true;

            try {
                StatusManager.updateStatus('loading', 'Loading API versions...');

                const response = await fetch('/api/docs/versions');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                // Validate response structure
                if (!data || typeof data !== 'object') {
                    throw new Error('Invalid response format from versions endpoint');
                }

                APIState.availableVersions = data.versions || [];
                APIState.currentVersion = data.default_version || (APIState.availableVersions.length > 0 ? APIState.availableVersions[0].version : null);

                console.log(`Loaded ${APIState.availableVersions.length} API versions, default: ${APIState.currentVersion}`);

                this.populateVersionSelector();

                // Load the current version
                if (APIState.currentVersion && APIState.availableVersions.length > 0) {
                    await this.loadSchema();
                } else {
                    throw new Error('No API versions available');
                }

            } catch (error) {
                console.error('Failed to load versions:', error);
                ErrorHandler.handleApiError(error, 'Failed to load API versions');

                // Update version selector to show error state
                const selector = document.getElementById('version-selector');
                if (selector) {
                    selector.innerHTML = '<option value="">Error loading versions</option>';
                }

                StatusManager.updateStatus('error', 'Failed to load versions');
            } finally {
                this.loadingState.versions = false;
            }
        },

        async loadSchema() {
            if (!APIState.currentVersion) {
                throw new Error('No API version selected');
            }

            if (this.loadingState.schema) {
                console.log('Schema already loading, skipping duplicate request');
                return;
            }

            this.loadingState.schema = true;
            this.loadingState.config = true;

            try {
                StatusManager.updateStatus('loading', 'Loading schema configuration...');

                // Initialize schema configuration first with better error handling
                try {
                    await APISchemaManager.init();
                    console.log('Schema configuration loaded successfully');
                } catch (configError) {
                    console.warn('Schema configuration load failed, using fallbacks:', configError);
                    // Continue with schema loading even if config fails
                }

                StatusManager.updateStatus('loading', 'Loading API schema...');

                const url = `/api/docs/${APIState.currentVersion}`;
                console.log(`Loading schema from: ${url}`);

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const schemaData = await response.json();

                // Validate response structure
                if (!schemaData || typeof schemaData !== 'object') {
                    throw new Error('Invalid schema data received');
                }

                console.log(`Schema loaded for version ${APIState.currentVersion}:`, {
                    endpoints: schemaData.endpoints?.length || 0,
                    components: Object.keys(schemaData.components || {}).length
                });

                // Validate and process the schema
                this.processSchema(schemaData);

                StatusManager.updateStatus('success', 'Schema loaded successfully');
                StatusManager.updateVersionBadge();

                // Update UI
                this.populateOverview();
                this.updateRawContent();
                this.showFilters();

            } catch (error) {
                console.error('Schema loading failed:', error);
                ErrorHandler.handleApiError(error, 'Failed to load API schema');
                StatusManager.updateStatus('error', `Failed to load schema: ${error.message}`);
                throw error;
            } finally {
                this.loadingState.schema = false;
                this.loadingState.config = false;
            }
        },

        processSchema(schemaData) {
            try {
                StatusManager.updateStatus('loading', 'Processing schema data...');

                // Reset state
                APIState.reset();

                // Store schema
                APIState.openApiSchema = schemaData;

                // Extract and validate endpoints
                const endpoints = schemaData.endpoints || [];
                console.log(`Processing ${endpoints.length} endpoints`);

                // Validate endpoints structure
                const validEndpoints = endpoints.filter(endpoint => {
                    if (!endpoint || !endpoint.method || !endpoint.path) {
                        console.warn('Invalid endpoint detected:', endpoint);
                        return false;
                    }
                    return true;
                });

                if (validEndpoints.length !== endpoints.length) {
                    console.warn(`Filtered out ${endpoints.length - validEndpoints.length} invalid endpoints`);
                }

                APIState.setEndpoints(validEndpoints);

                // Extract components
                APIState.apiComponents = schemaData.components || {};
                console.log(`Loaded ${Object.keys(APIState.apiComponents).length} schema components`);

                // Calculate statistics
                APIState.apiStats = SchemaProcessor.calculateStats(APIState.allEndpoints);
                console.log('Schema statistics:', APIState.apiStats);

                // Update UI components
                this.updateStats();
                FilterController.populateFilterOptions(APIState.apiStats);
                EndpointRenderer.render();
                FilterController.updateFilterSummary();

                console.log('Schema processing completed successfully');

            } catch (error) {
                console.error('Schema processing failed:', error);
                throw new Error(`Schema processing failed: ${error.message}`);
            }
        },

        populateVersionSelector() {
            const selector = document.getElementById('version-selector');
            if (!selector) return;

            selector.innerHTML = APIState.availableVersions.map(version => {
                const statusBadge = version.status ? ` [${version.status}]` : '';
                const title = version.config?.title || version.version;
                const semanticVersion = version.config?.version || 'unknown';
                const displayText = `${title} (${semanticVersion})${statusBadge}`;
                const isDefault = version.version === APIState.currentVersion ? ' - default' : '';

                return `<option value="${version.version}" ${version.version === APIState.currentVersion ? 'selected' : ''}>
                    ${displayText}${isDefault}
                </option>`;
            }).join('');

            // Remove any existing event listeners by cloning the element
            const newSelector = selector.cloneNode(true);
            selector.parentNode.replaceChild(newSelector, selector);

            newSelector.addEventListener('change', async (e) => {
                if (e.target.value && e.target.value !== APIState.currentVersion) {
                    const previousVersion = APIState.currentVersion;
                    APIState.currentVersion = e.target.value;

                    console.log(`Switching API version from ${previousVersion} to ${APIState.currentVersion}`);

                    // Clear filters when version changes
                    FilterController.clearFilters();

                    // Show loading state
                    StatusManager.updateStatus('loading', `Switching to version ${APIState.currentVersion}...`);

                    try {
                        // Reset schema configuration for new version
                        APIState.schemaConfig = null;
                        APISchemaManager.initialized = false;
                        APISchemaManager.configValidated = false;

                        await this.loadSchema();
                    } catch (error) {
                        console.error('Failed to load schema for version:', APIState.currentVersion, error);
                        ErrorHandler.handleApiError(error, `Failed to load schema for version ${APIState.currentVersion}`);

                        // Revert to previous version on failure
                        APIState.currentVersion = previousVersion;
                        e.target.value = previousVersion;
                    }
                }
            });
        },

        populateOverview() {
            const schema = APIState.openApiSchema;
            if (!schema) return;

            // Update title and description
            const title = document.getElementById('api-title');
            const headerTitle = document.getElementById('api-header-title');
            const description = document.getElementById('api-description');

            if (title) title.textContent = schema.title || 'API Documentation';
            if (headerTitle) headerTitle.textContent = schema.title || 'API Documentation';
            if (description) description.textContent = schema.description || 'No description available';

            // Show overview section
            const overview = document.getElementById('api-overview');
            if (overview) overview.style.display = 'block';
        },

        updateStats() {
            if (!APIState.apiStats) return;

            const stats = APIState.apiStats;

            // Update endpoint count
            const endpointCount = document.getElementById('api-endpoints-count');
            if (endpointCount) endpointCount.textContent = stats.total_endpoints;

            // Update detailed stats if elements exist
            const authRequired = document.getElementById('stats-auth-required');
            const uniquePaths = document.getElementById('stats-unique-paths');
            const totalTags = document.getElementById('stats-total-tags');

            if (authRequired) authRequired.textContent = stats.auth_required_count;
            if (uniquePaths) uniquePaths.textContent = stats.unique_paths_count;
            if (totalTags) totalTags.textContent = stats.total_tags || 0;
        },

        updateRawContent() {
            this.updateRawSchema('json');
            this.updateComponents('json');
        },

        updateRawSchema(format) {
            const content = document.getElementById('raw-schema-content');
            if (!content) {
                console.warn('Raw schema content element not found');
                return;
            }

            if (!APIState.openApiSchema) {
                content.textContent = 'No schema data available. Try refreshing the page or selecting a different version.';
                return;
            }

            try {
                if (format === 'yaml') {
                    content.textContent = SchemaProcessor.jsonToYaml(APIState.openApiSchema);
                } else {
                    content.innerHTML = SchemaProcessor.syntaxHighlight(APIState.openApiSchema);
                }

                // Ensure content is visible
                if (!content.textContent && !content.innerHTML) {
                    content.textContent = 'Failed to render schema content. Please try switching formats or refreshing.';
                }
            } catch (error) {
                console.error('Error formatting schema:', error);
                content.textContent = `Error formatting schema: ${error.message}`;
            }
        },

        updateComponents(format) {
            const content = document.getElementById('components-content');
            if (!content) {
                console.warn('Components content element not found');
                return;
            }

            const components = APIState.apiComponents || {};

            try {
                if (Object.keys(components).length === 0) {
                    content.textContent = 'No components defined in this API schema.';
                    return;
                }

                if (format === 'yaml') {
                    content.textContent = SchemaProcessor.jsonToYaml(components);
                } else {
                    content.innerHTML = SchemaProcessor.syntaxHighlight(components);
                }

                // Ensure content is visible
                if (!content.textContent && !content.innerHTML) {
                    content.textContent = 'Failed to render components content. Please try switching formats or refreshing.';
                }
            } catch (error) {
                console.error('Error formatting components:', error);
                content.textContent = `Error formatting components: ${error.message}`;
            }
        },

        showFilters() {
            const filtersDiv = document.getElementById('api-filters');
            if (filtersDiv) filtersDiv.style.display = 'block';
        }
    };

    // =============================================================================
    // FORMAT SWITCHING CONTROLLERS
    // =============================================================================

    const FormatController = {
        init() {
            this.initSchemaFormatSwitchers();
            this.initComponentsFormatSwitchers();
            this.initCopyButtons();
        },

        initSchemaFormatSwitchers() {
            const jsonBtn = document.getElementById('json-format-btn');
            const yamlBtn = document.getElementById('yaml-format-btn');

            if (jsonBtn && yamlBtn) {
                jsonBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (jsonBtn.classList.contains('active')) return;
                    this.switchFormat(jsonBtn, yamlBtn, 'json', 'raw');
                });

                yamlBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (yamlBtn.classList.contains('active')) return;
                    this.switchFormat(yamlBtn, jsonBtn, 'yaml', 'raw');
                });
            }
        },

        initComponentsFormatSwitchers() {
            const jsonBtn = document.getElementById('components-json-format-btn');
            const yamlBtn = document.getElementById('components-yaml-format-btn');

            if (jsonBtn && yamlBtn) {
                jsonBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (jsonBtn.classList.contains('active')) return;
                    this.switchFormat(jsonBtn, yamlBtn, 'json', 'components');
                });

                yamlBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (yamlBtn.classList.contains('active')) return;
                    this.switchFormat(yamlBtn, jsonBtn, 'yaml', 'components');
                });
            }
        },

        initCopyButtons() {
            const rawCopyBtn = document.getElementById('copy-raw-schema-btn');
            const componentsCopyBtn = document.getElementById('copy-components-btn');

            if (rawCopyBtn) {
                rawCopyBtn.addEventListener('click', () => {
                    this.copyToClipboard('raw-schema-content', rawCopyBtn);
                });
            }

            if (componentsCopyBtn) {
                componentsCopyBtn.addEventListener('click', () => {
                    this.copyToClipboard('components-content', componentsCopyBtn);
                });
            }
        },

        switchFormat(activeBtn, inactiveBtn, format, type) {
            // Update button states
            activeBtn.classList.add('active');
            inactiveBtn.classList.remove('active');

            // Update content
            if (type === 'raw') {
                APILoader.updateRawSchema(format);
            } else if (type === 'components') {
                APILoader.updateComponents(format);
            }
        },

        copyToClipboard(contentElementId, buttonElement) {
            const content = document.getElementById(contentElementId);
            if (!content) return;

            const text = content.textContent || content.innerText;
            navigator.clipboard.writeText(text).then(() => {
                const originalHtml = buttonElement.innerHTML;
                buttonElement.innerHTML = '<i class="ri-check-line"></i> Copied!';
                buttonElement.classList.add('btn-success');
                buttonElement.classList.remove('btn-secondary');

                setTimeout(() => {
                    buttonElement.innerHTML = originalHtml;
                    buttonElement.classList.remove('btn-success');
                    buttonElement.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy content:', err);
                const originalHtml = buttonElement.innerHTML;
                buttonElement.innerHTML = '<i class="ri-close-line"></i> Failed';
                buttonElement.classList.add('btn-danger');
                buttonElement.classList.remove('btn-secondary');

                setTimeout(() => {
                    buttonElement.innerHTML = originalHtml;
                    buttonElement.classList.remove('btn-danger');
                    buttonElement.classList.add('btn-secondary');
                }, 2000);
            });
        }
    };
{{end}}
