{{define "api_loader_js"}}
    // =============================================================================
    // SIMPLIFIED API LOADER - FOR CLEAN OPENAPI BACKEND
    // =============================================================================

    const APILoader = {
        loadingState: {
            versions: false,
            endpoints: false
        },

        // Get superuser authentication token from localStorage
        getSuperuserAuthToken() {
            try {
                const authData = localStorage.getItem('__pb_superuser_auth__');
                if (!authData) {
                    return null;
                }

                const parsed = JSON.parse(authData);
                return parsed.token || null;
            } catch (error) {
                console.error('❌ Failed to parse superuser auth token:', error);
                return null;
            }
        },

        // Create authenticated fetch options
        getAuthenticatedFetchOptions(options = {}) {
            const token = this.getSuperuserAuthToken();
            if (!token) {
                throw new Error('SuperUser authentication required');
            }

            return {
                ...options,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            };
        },

        // Load available API versions
        async loadVersions() {
            if (this.loadingState.versions) {
                console.log('Versions already loading, skipping duplicate request');
                return;
            }

            this.loadingState.versions = true;

            try {
                this.updateStatus('loading', 'Loading API versions...');

                const response = await fetch('/api/docs/versions', this.getAuthenticatedFetchOptions());
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('SuperUser authentication required. Please log in as superuser.');
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (!data || !data.versions) {
                    throw new Error('Invalid response format from versions endpoint');
                }

                // Store version information
                APIState.availableVersions = data.versions;
                APIState.currentVersion = data.default_version || (data.versions.length > 0 ? data.versions[0].version : null);

                console.log(`Loaded ${data.versions.length} API versions, default: ${APIState.currentVersion}`);

                // Update UI
                this.populateVersionSelector();

                // Load the current version's endpoints
                if (APIState.currentVersion) {
                    await this.loadEndpoints();
                } else {
                    throw new Error('No API versions available');
                }

            } catch (error) {
                console.error('Failed to load API versions:', error);
                this.updateStatus('error', `Failed to load API versions: ${error.message}`);
                throw error;
            } finally {
                this.loadingState.versions = false;
            }
        },

        // Load OpenAPI spec for current version
        async loadEndpoints() {
            if (this.loadingState.endpoints) {
                console.log('Endpoints already loading, skipping duplicate request');
                return;
            }

            this.loadingState.endpoints = true;

            try {
                const version = APIState.currentVersion;
                if (!version) {
                    throw new Error('No current version selected');
                }

                this.updateStatus('loading', `Loading endpoints for version ${version}...`);

                const response = await fetch(`/api/docs/${version}`, this.getAuthenticatedFetchOptions());
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('SuperUser authentication required. Please log in as superuser.');
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const openApiSpec = await response.json();
                if (!openApiSpec || !openApiSpec.endpoints) {
                    throw new Error('Invalid OpenAPI specification received');
                }

                // Store the clean OpenAPI data - no conversion needed!
                APIState.openApiSchema = openApiSpec;
                APIState.allEndpoints = openApiSpec.endpoints;
                APIState.setEndpoints(openApiSpec.endpoints);

                console.log(`Loaded ${openApiSpec.endpoints.length} endpoints for version ${version}`);

                // Update UI
                this.updateEndpointsList();
                this.updateStatsDisplay();
                this.updateVersionDisplay();
                this.initializeFilters();

                // Update other tabs with OpenAPI data
                this.updateRawSchema('json');
                this.updateComponents('json');

                this.updateStatus('success', `Loaded ${openApiSpec.endpoints.length} endpoints`);

            } catch (error) {
                console.error('Failed to load endpoints:', error);
                this.updateStatus('error', `Failed to load endpoints: ${error.message}`);
                throw error;
            } finally {
                this.loadingState.endpoints = false;
            }
        },

        // Switch to different API version
        async switchVersion(newVersion) {
            if (newVersion === APIState.currentVersion) {
                console.log(`Already on version ${newVersion}`);
                return;
            }

            console.log(`Switching from ${APIState.currentVersion} to ${newVersion}`);
            APIState.currentVersion = newVersion;

            // Clear current data
            APIState.allEndpoints = [];
            APIState.filteredEndpoints = [];
            APIState.openApiSchema = null;

            // Load new version
            await this.loadEndpoints();
        },

        // Populate version selector dropdown
        populateVersionSelector() {
            const versionSelect = document.getElementById('version-select');
            if (!versionSelect || !APIState.availableVersions.length) {
                return;
            }

            versionSelect.innerHTML = '';

            APIState.availableVersions.forEach(versionInfo => {
                const option = document.createElement('option');
                option.value = versionInfo.version;

                // Simple display: just version name
                const displayName = versionInfo.config?.title ?
                    `${versionInfo.config.title} ${versionInfo.version}` :
                    versionInfo.version;

                option.textContent = displayName;
                option.selected = versionInfo.version === APIState.currentVersion;
                versionSelect.appendChild(option);
            });

            // Add change event listener
            versionSelect.removeEventListener('change', this.handleVersionChange);
            versionSelect.addEventListener('change', this.handleVersionChange.bind(this));
        },

        // Handle version selection change
        async handleVersionChange(event) {
            const newVersion = event.target.value;
            if (newVersion && newVersion !== APIState.currentVersion) {
                try {
                    await this.switchVersion(newVersion);
                } catch (error) {
                    console.error('Failed to switch version:', error);
                    // Revert selection on error
                    event.target.value = APIState.currentVersion;
                }
            }
        },

        // Update endpoints list in UI
        updateEndpointsList() {
            if (typeof EndpointRenderer !== 'undefined' && EndpointRenderer.render) {
                EndpointRenderer.render();
            } else {
                console.error('EndpointRenderer not available');
            }
        },

        // Update statistics display
        updateStatsDisplay() {
            const stats = this.calculateStats();
            APIState.apiStats = stats;

            if (typeof UIController !== 'undefined' && UIController.updateStatistics) {
                UIController.updateStatistics(stats);
            }
        },

        // Update version display information
        updateVersionDisplay() {
            const versionInfo = APIState.availableVersions.find(v => v.version === APIState.currentVersion);
            if (!versionInfo) return;

            // Simple version display - just update the page title if available
            const title = versionInfo.config?.title || 'API Documentation';
            const version = versionInfo.config?.version || versionInfo.version;

            if (document.title.includes('API')) {
                document.title = `${title} ${version} - PocketBase`;
            }
        },

        // Initialize filter options
        initializeFilters() {
            if (typeof UIController !== 'undefined') {
                const stats = APIState.apiStats || this.calculateStats();
                if (UIController.populateFilterOptions) {
                    UIController.populateFilterOptions(stats);
                }

                // Show filters section
                const filtersSection = document.getElementById('api-filters');
                if (filtersSection) {
                    filtersSection.style.display = 'block';
                }
            }
        },

        // Update raw schema display
        updateRawSchema(format = 'json') {
            const rawContent = document.getElementById('raw-schema-content');
            if (!rawContent) {
                console.warn('Raw schema content element not found');
                return;
            }

            if (!APIState.openApiSchema) {
                rawContent.innerHTML = '<code>No schema data available</code>';
                return;
            }

            try {
                let content;
                if (format === 'yaml' && typeof SchemaProcessor !== 'undefined') {
                    content = SchemaProcessor.jsonToYaml(APIState.openApiSchema);
                } else {
                    content = JSON.stringify(APIState.openApiSchema, null, 2);
                }

                // Use SchemaProcessor for syntax highlighting if available
                if (typeof SchemaProcessor !== 'undefined') {
                    const highlighted = SchemaProcessor.syntaxHighlight(content, format);
                    rawContent.innerHTML = highlighted;
                } else {
                    rawContent.innerHTML = `<code>${this._escapeHtml(content)}</code>`;
                }

                console.log(`Raw schema updated in ${format} format`);
            } catch (error) {
                console.error('Failed to update raw schema:', error);
                rawContent.innerHTML = `<code class="txt-danger">Error formatting schema: ${error.message}</code>`;
            }
        },

        // Update components schema display
        updateComponents(format = 'json') {
            const componentsContent = document.getElementById('components-content');
            if (!componentsContent) {
                console.warn('Components content element not found');
                return;
            }

            if (!APIState.openApiSchema?.components || Object.keys(APIState.openApiSchema.components).length === 0) {
                componentsContent.innerHTML = '<code>No components available</code>';
                return;
            }

            try {
                let content;
                if (format === 'yaml' && typeof SchemaProcessor !== 'undefined') {
                    content = SchemaProcessor.jsonToYaml(APIState.openApiSchema.components);
                } else {
                    content = JSON.stringify(APIState.openApiSchema.components, null, 2);
                }

                // Use SchemaProcessor for syntax highlighting if available
                if (typeof SchemaProcessor !== 'undefined') {
                    const highlighted = SchemaProcessor.syntaxHighlight(content, format);
                    componentsContent.innerHTML = highlighted;
                } else {
                    componentsContent.innerHTML = `<code>${this._escapeHtml(content)}</code>`;
                }

                console.log(`Components updated in ${format} format`);
            } catch (error) {
                console.error('Failed to update components:', error);
                componentsContent.innerHTML = `<code class="txt-danger">Error formatting components: ${error.message}</code>`;
            }
        },

        // Helper method for HTML escaping
        _escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        // Calculate statistics from endpoints
        calculateStats() {
            const endpoints = APIState.allEndpoints || [];

            const stats = {
                totalEndpoints: endpoints.length,
                methods: {},
                tags: {},
                authTypes: {}
            };

            endpoints.forEach(endpoint => {
                // Count methods
                const method = endpoint.method || 'UNKNOWN';
                stats.methods[method] = (stats.methods[method] || 0) + 1;

                // Count tags
                (endpoint.tags || []).forEach(tag => {
                    stats.tags[tag] = (stats.tags[tag] || 0) + 1;
                });

                // Count auth types
                const authType = endpoint.auth?.type || 'none';
                stats.authTypes[authType] = (stats.authTypes[authType] || 0) + 1;
            });

            return stats;
        },



        // Update status message
        updateStatus(type, message) {
            if (typeof ErrorStatusManager !== 'undefined') {
                ErrorStatusManager.updateStatus(type, message);
            } else if (typeof StatusManager !== 'undefined') {
                StatusManager.updateStatus(type, message);
            } else {
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        },

        // Check if currently loading
        isLoading() {
            return this.loadingState.versions || this.loadingState.endpoints;
        },

        // Initialize the API loader
        async initialize() {
            try {
                await this.loadVersions();
                return true;
            } catch (error) {
                console.error('Failed to initialize API loader:', error);
                return false;
            }
        },

        // DEBUG METHODS FOR TROUBLESHOOTING
        getDebugInfo() {
            return {
                timestamp: new Date().toISOString(),
                loading: {
                    versions: this.loadingState.versions,
                    endpoints: this.loadingState.endpoints
                },
                auth: {
                    hasToken: !!this.getSuperuserAuthToken(),
                    tokenPreview: this.getSuperuserAuthToken()?.substring(0, 20) + '...' || null
                },
                state: {
                    availableVersions: APIState.availableVersions?.length || 0,
                    currentVersion: APIState.currentVersion,
                    allEndpoints: APIState.allEndpoints?.length || 0,
                    filteredEndpoints: APIState.filteredEndpoints?.length || 0
                },
                components: {
                    APIState: typeof APIState,
                    UIController: typeof UIController,
                    EndpointRenderer: typeof EndpointRenderer,
                    ErrorStatusManager: typeof ErrorStatusManager
                },
                dom: {
                    versionSelect: !!document.getElementById('version-select'),
                    endpointsList: !!document.getElementById('endpoints-list'),
                    apiFilters: !!document.getElementById('api-filters')
                }
            };
        },

        async testConnection() {
            console.log('🧪 Testing API connection...');
            try {
                const response = await fetch('/api/docs/versions', this.getFetchOptions(false));
                console.log('✅ Connection test successful:', response.status, response.statusText);
                const data = await response.json();
                console.log('📊 Response data:', data);
                return { success: true, status: response.status, data };
            } catch (error) {
                console.error('❌ Connection test failed:', error);
                return { success: false, error: error.message };
            }
        },

        async forceReload() {
            console.log('🔄 Force reloading API data...');
            this.loadingState.versions = false;
            this.loadingState.endpoints = false;
            APIState.reset();
            return await this.initialize();
        },

        checkDependencies() {
            const deps = {
                APIState: typeof APIState !== 'undefined',
                UIController: typeof UIController !== 'undefined',
                EndpointRenderer: typeof EndpointRenderer !== 'undefined',
                ErrorStatusManager: typeof ErrorStatusManager !== 'undefined'
            };

            console.log('🔍 Dependency check:', deps);
            const missing = Object.entries(deps).filter(([name, available]) => !available);

            if (missing.length > 0) {
                console.error('❌ Missing dependencies:', missing.map(([name]) => name));
                return { success: false, missing: missing.map(([name]) => name) };
            } else {
                console.log('✅ All dependencies available');
                return { success: true };
            }
        }
    };

    // Export for global use
    if (typeof window !== 'undefined') {
        window.APILoader = APILoader;

        // Global debug helper for troubleshooting
        window.APIDebug = window.APIDebug || {};
        window.APIDebug.loader = {
            // Quick status check
            status: () => APILoader.getDebugInfo(),

            // Test API connection
            test: () => APILoader.testConnection(),

            // Force reload API data
            reload: () => APILoader.forceReload(),

            // Check component dependencies
            deps: () => APILoader.checkDependencies(),

            // Get auth token info
            auth: () => ({
                hasToken: !!APILoader.getSuperuserAuthToken(),
                tokenPreview: APILoader.getSuperuserAuthToken()?.substring(0, 20) + '...' || null
            }),

            // Manual initialization
            init: () => APILoader.initialize(),

            // Current state snapshot
            state: () => ({
                versions: APIState?.availableVersions || [],
                currentVersion: APIState?.currentVersion,
                endpoints: APIState?.allEndpoints?.length || 0,
                filtered: APIState?.filteredEndpoints?.length || 0
            })
        };

        console.log('🔧 Debug helper available: window.APIDebug.loader');
        console.log('💡 Try: APIDebug.loader.status() or APIDebug.loader.test()');
    }

{{end}}
