{{define "api_loader_js"}}
    // =============================================================================
    // API LOADER - SIMPLIFIED FOR AST-BASED VERSIONED SYSTEM
    // =============================================================================

    const APILoader = {
        loadingState: {
            versions: false,
            endpoints: false
        },

        // Load available API versions
        async loadVersions() {
            if (this.loadingState.versions) {
                console.log('Versions already loading, skipping duplicate request');
                return;
            }

            this.loadingState.versions = true;

            try {
                if (typeof ErrorStatusManager !== 'undefined') {
                    ErrorStatusManager.updateStatus('loading', 'Loading API versions...');
                } else if (typeof StatusManager !== 'undefined') {
                    StatusManager.updateStatus('loading', 'Loading API versions...');
                }

                const response = await fetch('/api/docs/versions');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                // Validate response structure
                if (!data || typeof data !== 'object') {
                    throw new Error('Invalid response format from versions endpoint');
                }

                APIState.availableVersions = data.versions || [];
                APIState.currentVersion = data.default_version || (APIState.availableVersions.length > 0 ? APIState.availableVersions[0].version : null);

                console.log(`Loaded ${APIState.availableVersions.length} API versions, default: ${APIState.currentVersion}`);

                this.populateVersionSelector();

                // Load the current version's endpoints
                if (APIState.currentVersion && APIState.availableVersions.length > 0) {
                    await this.loadEndpoints();
                } else {
                    throw new Error('No API versions available');
                }

            } catch (error) {
                console.error('Failed to load API versions:', error);
                throw error;
            } finally {
                this.loadingState.versions = false;
            }
        },

        // Load endpoints for current version
        async loadEndpoints() {
            if (this.loadingState.endpoints) {
                console.log('Endpoints already loading, skipping duplicate request');
                return;
            }

            this.loadingState.endpoints = true;

            try {
                const version = APIState.currentVersion;
                if (!version) {
                    throw new Error('No current version selected');
                }

                if (typeof ErrorStatusManager !== 'undefined') {
                    ErrorStatusManager.updateStatus('loading', `Loading endpoints for version ${version}...`);
                } else if (typeof StatusManager !== 'undefined') {
                    StatusManager.updateStatus('loading', `Loading endpoints for version ${version}...`);
                }

                const response = await fetch(`/api/docs/${version}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                // Validate response structure
                if (!data || typeof data !== 'object') {
                    throw new Error('Invalid response format from endpoints API');
                }

                // Set schema and endpoints data
                APIState.openApiSchema = data;
                APIState.allEndpoints = data.endpoints || [];
                APIState.setEndpoints(data.endpoints || []);

                console.log(`Loaded ${APIState.allEndpoints.length} endpoints for version ${version}`);

                // Update UI components
                this.updateEndpointsList();
                this.updateStatsDisplay();

                // Update version display and description
                this.updateVersionDisplay();

                // Initialize filter options and update UI
                if (typeof UIController !== 'undefined') {
                    const stats = this.calculateStats();
                    if (UIController.populateFilterOptions) {
                        UIController.populateFilterOptions(stats);
                    }
                    // Ensure statistics are updated
                    if (UIController._updateStatistics) {
                        UIController._updateStatistics();
                    }
                    // Show the filters section
                    const filtersSection = document.getElementById('api-filters');
                    if (filtersSection) {
                        filtersSection.style.display = 'block';
                    }
                } else if (typeof FilterController !== 'undefined' && FilterController.populateFilterOptions) {
                    // Fallback for backward compatibility
                    const stats = this.calculateStats();
                    FilterController.populateFilterOptions(stats);
                }

            } catch (error) {
                console.error('Failed to load endpoints:', error);
                throw error;
            } finally {
                this.loadingState.endpoints = false;
            }
        },

        // Populate version selector dropdown
        populateVersionSelector() {
            const versionSelect = document.getElementById('version-select');
            if (!versionSelect || !APIState.availableVersions.length) {
                return;
            }

            // Clear existing options
            versionSelect.innerHTML = '';

            // Add version options with correct version info
            APIState.availableVersions.forEach(versionInfo => {
                const option = document.createElement('option');
                option.value = versionInfo.version;

                // Use the version info from the versions API, not current schema
                const apiTitle = versionInfo.config?.title || 'API';
                const apiVersion = versionInfo.config?.version || versionInfo.version;
                const status = versionInfo.status || 'stable';

                option.textContent = `${apiTitle} v${apiVersion} (${status})`;
                option.selected = versionInfo.version === APIState.currentVersion;
                versionSelect.appendChild(option);
            });

            // Add change listener
            versionSelect.addEventListener('change', async (e) => {
                const newVersion = e.target.value;
                if (newVersion !== APIState.currentVersion) {
                    await this.switchVersion(newVersion);
                }
            });
        },

        // Switch to different API version
        async switchVersion(newVersion) {
            if (!newVersion || newVersion === APIState.currentVersion) {
                return;
            }

            try {
                if (typeof ErrorStatusManager !== 'undefined') {
                    ErrorStatusManager.updateStatus('loading', `Switching to version ${newVersion}...`);
                } else if (typeof StatusManager !== 'undefined') {
                    StatusManager.updateStatus('loading', `Switching to version ${newVersion}...`);
                }

                // Reset state first
                APIState.reset();

                // Then update current version
                APIState.currentVersion = newVersion;

                // Load new version's endpoints
                await this.loadEndpoints();

                console.log(`Switched to API version ${newVersion}`);

            } catch (error) {
                console.error('Failed to switch version:', error);

                // Revert version selector
                const versionSelect = document.getElementById('version-select');
                if (versionSelect) {
                    versionSelect.value = APIState.currentVersion;
                }
            }
        },

        // Update endpoints list in UI
        updateEndpointsList() {
            // Render endpoints using EndpointRenderer
            if (typeof EndpointRenderer !== 'undefined' && EndpointRenderer.render) {
                EndpointRenderer.render();
            }

            // Update endpoint count display and statistics
            if (typeof UIController !== 'undefined' && UIController._updateStatistics) {
                UIController._updateStatistics();
            } else {
                // Fallback: direct update
                const countElement = document.getElementById('api-endpoints-count');
                if (countElement) {
                    countElement.textContent = APIState.filteredEndpoints.length;
                }
            }

            // Update version info display
            this.updateVersionInfo();
        },

        // Update version information display
        updateVersionInfo() {
            // Update version selector display with detailed info
            const versionSelect = document.getElementById('version-select');
            if (versionSelect && APIState.availableVersions.length > 0) {
                // Clear and repopulate with detailed version info
                versionSelect.innerHTML = '';

                APIState.availableVersions.forEach(versionData => {
                    const option = document.createElement('option');
                    option.value = versionData.version;

                    // Create detailed version display
                    const statusText = versionData.status ? ` (${versionData.status})` : '';
                    const endpointCount = versionData.endpoints || 0;
                    option.textContent = `${versionData.version}${statusText} - ${endpointCount} endpoints`;

                    option.selected = versionData.version === APIState.currentVersion;
                    versionSelect.appendChild(option);
                });
            }

            // Update version selector and description display
            this.updateVersionDisplay();
        },

        // Update version display and description
        updateVersionDisplay() {
            // Update version selector options to include full API info
            this.populateVersionSelector();

            // Display API description separately
            this.displayAPIDescription();
        },

        // Display API description
        displayAPIDescription() {
            // Look for or create description container
            let descContainer = document.getElementById('api-description-display');

            if (!descContainer) {
                // Create container after version selector
                const versionSelect = document.getElementById('version-select');
                if (versionSelect && versionSelect.parentElement && versionSelect.parentElement.parentElement) {
                    descContainer = document.createElement('div');
                    descContainer.id = 'api-description-display';
                    descContainer.className = 'api-description-inline';
                    versionSelect.parentElement.parentElement.appendChild(descContainer);
                }
            }

            if (descContainer && APIState.openApiSchema) {
                const description = APIState.openApiSchema.description;
                if (description && description.trim()) {
                    descContainer.textContent = description;
                    descContainer.style.display = 'block';
                } else {
                    descContainer.style.display = 'none';
                }
            }
        },

        // Get CSS class for version status badge
        getStatusBadgeClass(status) {
            switch (status) {
                case 'stable': return 'success';
                case 'testing': return 'warning';
                case 'development': return 'info';
                case 'deprecated': return 'danger';
                default: return 'secondary';
            }
        },

        // Update raw schema content using SchemaProcessor
        updateRawSchema(format = 'json') {
            const rawContent = document.getElementById('raw-schema-content');
            if (!rawContent || !APIState.openApiSchema) {
                if (rawContent) {
                    rawContent.innerHTML = '<div class="code-block"><span class="json-null">No schema data available</span></div>';
                }
                return;
            }

            try {
                if (typeof SchemaProcessor !== 'undefined') {
                    SchemaProcessor.updateElement('raw-schema-content', APIState.openApiSchema, format);
                } else {
                    // Fallback if SchemaProcessor is not available
                    const content = format === 'yaml'
                        ? this._basicYamlConvert(APIState.openApiSchema)
                        : JSON.stringify(APIState.openApiSchema, null, 2);
                    rawContent.innerHTML = `<div class="code-block"><pre><code>${this._escapeHtml(content)}</code></pre></div>`;
                }
            } catch (error) {
                rawContent.innerHTML = `<div class="code-block"><span class="error">Error formatting schema: ${error.message}</span></div>`;
                console.error('Failed to update raw schema:', error);
            }
        },

        // Update components content using SchemaProcessor
        updateComponents(format = 'json') {
            const componentsContent = document.getElementById('components-content');
            if (!componentsContent) return;

            try {
                const components = APIState.openApiSchema?.components || {};

                if (Object.keys(components).length === 0) {
                    componentsContent.innerHTML = '<div class="code-block"><span class="json-null">No components available in this API schema</span></div>';
                    return;
                }

                if (typeof SchemaProcessor !== 'undefined') {
                    SchemaProcessor.updateElement('components-content', components, format);
                } else {
                    // Fallback if SchemaProcessor is not available
                    const content = format === 'yaml'
                        ? this._basicYamlConvert(components)
                        : JSON.stringify(components, null, 2);
                    componentsContent.innerHTML = `<div class="code-block"><pre><code>${this._escapeHtml(content)}</code></pre></div>`;
                }
            } catch (error) {
                componentsContent.innerHTML = `<div class="code-block"><span class="error">Error formatting components: ${error.message}</span></div>`;
                console.error('Failed to update components:', error);
            }
        },

        // Basic YAML conversion fallback
        _basicYamlConvert(obj) {
            try {
                return JSON.stringify(obj, null, 2).replace(/"/g, '').replace(/,\n/g, '\n').replace(/{\n/g, ':\n').replace(/}/g, '');
            } catch (error) {
                return JSON.stringify(obj, null, 2);
            }
        },

        // HTML escape utility
        _escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        // Update statistics display
        updateStatsDisplay() {
            const statsContainer = document.getElementById('api-stats');
            if (!statsContainer) return;

            const stats = this.calculateStats();

            statsContainer.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value">${stats.endpoints}</span>
                        <span class="stat-label">Endpoints</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">${stats.methods}</span>
                        <span class="stat-label">Methods</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">${stats.auth}</span>
                        <span class="stat-label">Auth Required</span>
                    </div>
                </div>
            `;
        },

        // Calculate statistics
        calculateStats() {
            const endpoints = APIState.allEndpoints;

            return {
                endpoints: endpoints.length,
                methods: new Set(endpoints.map(ep => ep.method)).size,
                auth: endpoints.filter(ep => ep.auth?.required).length
            };
        },

        // Refresh all data
        refresh() {
            return this.loadVersions();
        },

        // Check if loader is ready
        isReady() {
            return !this.loadingState.versions && !this.loadingState.endpoints && APIState.allEndpoints.length > 0;
        },

        // Check if loader is loading
        isLoading() {
            return this.loadingState.versions || this.loadingState.endpoints;
        }
    };
{{end}}
