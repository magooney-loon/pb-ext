{{define "api_loader_js"}}
    // =============================================================================
    // DATA LOADING AND INITIALIZATION
    // =============================================================================

    const APILoader = {
        async loadVersions() {
            try {
                StatusManager.updateStatus('loading', 'Loading versions...');

                const response = await fetch('/api/docs/versions');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                APIState.availableVersions = data.versions || [];
                APIState.currentVersion = data.default_version || (APIState.availableVersions.length > 0 ? APIState.availableVersions[0].version : null);

                this.populateVersionSelector();

                // Load the current version
                if (APIState.currentVersion && APIState.availableVersions.length > 0) {
                    await this.loadSchema();
                } else {
                    throw new Error('No API versions available');
                }

            } catch (error) {
                console.error('Failed to load versions:', error);
                ErrorHandler.handleApiError(error, 'Failed to load API versions');

                // Update version selector to show error state
                const selector = document.getElementById('version-selector');
                if (selector) {
                    selector.innerHTML = '<option value="">Error loading versions</option>';
                }
            }
        },

        async loadSchema() {
            if (!APIState.currentVersion) {
                throw new Error('No API version selected');
            }

            try {
                StatusManager.updateStatus('loading', 'Loading schema...');

                // Initialize schema configuration first
                await APISchemaManager.init();

                const url = `/api/docs/${APIState.currentVersion}`;

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const schemaData = await response.json();

                // Validate and process the schema
                this.processSchema(schemaData);

                StatusManager.updateStatus('success', 'Loaded');
                StatusManager.updateVersionBadge();

                // Update UI
                this.populateOverview();
                this.updateRawContent();
                this.showFilters();

            } catch (error) {
                ErrorHandler.handleApiError(error, 'Failed to load API schema');
                throw error;
            }
        },

        processSchema(schemaData) {
            // Reset state
            APIState.reset();

            // Store schema
            APIState.openApiSchema = schemaData;

            // Extract and validate endpoints
            const endpoints = schemaData.endpoints || [];
            APIState.setEndpoints(endpoints);

            // Extract components
            APIState.apiComponents = schemaData.components || {};

            // Calculate statistics
            APIState.apiStats = SchemaProcessor.calculateStats(APIState.allEndpoints);

            // Update UI components
            this.updateStats();
            FilterController.populateFilterOptions(APIState.apiStats);
            EndpointRenderer.render();
            FilterController.updateFilterSummary();
        },

        populateVersionSelector() {
            const selector = document.getElementById('version-selector');
            if (!selector) return;

            selector.innerHTML = APIState.availableVersions.map(version => {
                const statusBadge = version.status ? ` [${version.status}]` : '';
                const title = version.config?.title || version.version;
                const semanticVersion = version.config?.version || 'unknown';
                const displayText = `${title} (${semanticVersion})${statusBadge}`;
                const isDefault = version.version === APIState.currentVersion ? ' - default' : '';

                return `<option value="${version.version}" ${version.version === APIState.currentVersion ? 'selected' : ''}>
                    ${displayText}${isDefault}
                </option>`;
            }).join('');

            // Remove any existing event listeners by cloning the element
            const newSelector = selector.cloneNode(true);
            selector.parentNode.replaceChild(newSelector, selector);

            newSelector.addEventListener('change', async (e) => {
                if (e.target.value && e.target.value !== APIState.currentVersion) {
                    APIState.currentVersion = e.target.value;

                    // Clear filters when version changes
                    FilterController.clearFilters();

                    try {
                        await this.loadSchema();
                    } catch (error) {
                        console.error('Failed to load schema for version:', APIState.currentVersion, error);
                        ErrorHandler.handleApiError(error, `Failed to load schema for version ${APIState.currentVersion}`);
                    }
                }
            });
        },

        populateOverview() {
            const schema = APIState.openApiSchema;
            if (!schema) return;

            // Update title and description
            const title = document.getElementById('api-title');
            const headerTitle = document.getElementById('api-header-title');
            const description = document.getElementById('api-description');

            if (title) title.textContent = schema.title || 'API Documentation';
            if (headerTitle) headerTitle.textContent = schema.title || 'API Documentation';
            if (description) description.textContent = schema.description || 'No description available';

            // Show overview section
            const overview = document.getElementById('api-overview');
            if (overview) overview.style.display = 'block';
        },

        updateStats() {
            if (!APIState.apiStats) return;

            const stats = APIState.apiStats;

            // Update endpoint count
            const endpointCount = document.getElementById('api-endpoints-count');
            if (endpointCount) endpointCount.textContent = stats.total_endpoints;

            // Update detailed stats if elements exist
            const authRequired = document.getElementById('stats-auth-required');
            const uniquePaths = document.getElementById('stats-unique-paths');
            const totalTags = document.getElementById('stats-total-tags');

            if (authRequired) authRequired.textContent = stats.auth_required_count;
            if (uniquePaths) uniquePaths.textContent = stats.unique_paths_count;
            if (totalTags) totalTags.textContent = stats.total_tags || 0;
        },

        updateRawContent() {
            this.updateRawSchema('json');
            this.updateComponents('json');
        },

        updateRawSchema(format) {
            const content = document.getElementById('raw-schema-content');
            if (!content) {
                console.warn('Raw schema content element not found');
                return;
            }

            if (!APIState.openApiSchema) {
                content.textContent = 'No schema data available. Try refreshing the page or selecting a different version.';
                return;
            }

            try {
                if (format === 'yaml') {
                    content.textContent = SchemaProcessor.jsonToYaml(APIState.openApiSchema);
                } else {
                    content.innerHTML = SchemaProcessor.syntaxHighlight(APIState.openApiSchema);
                }

                // Ensure content is visible
                if (!content.textContent && !content.innerHTML) {
                    content.textContent = 'Failed to render schema content. Please try switching formats or refreshing.';
                }
            } catch (error) {
                console.error('Error formatting schema:', error);
                content.textContent = `Error formatting schema: ${error.message}`;
            }
        },

        updateComponents(format) {
            const content = document.getElementById('components-content');
            if (!content) {
                console.warn('Components content element not found');
                return;
            }

            const components = APIState.apiComponents || {};

            try {
                if (Object.keys(components).length === 0) {
                    content.textContent = 'No components defined in this API schema.';
                    return;
                }

                if (format === 'yaml') {
                    content.textContent = SchemaProcessor.jsonToYaml(components);
                } else {
                    content.innerHTML = SchemaProcessor.syntaxHighlight(components);
                }

                // Ensure content is visible
                if (!content.textContent && !content.innerHTML) {
                    content.textContent = 'Failed to render components content. Please try switching formats or refreshing.';
                }
            } catch (error) {
                console.error('Error formatting components:', error);
                content.textContent = `Error formatting components: ${error.message}`;
            }
        },

        showFilters() {
            const filtersDiv = document.getElementById('api-filters');
            if (filtersDiv) filtersDiv.style.display = 'block';
        }
    };

    // =============================================================================
    // FORMAT SWITCHING CONTROLLERS
    // =============================================================================

    const FormatController = {
        init() {
            this.initSchemaFormatSwitchers();
            this.initComponentsFormatSwitchers();
            this.initCopyButtons();
        },

        initSchemaFormatSwitchers() {
            const jsonBtn = document.getElementById('json-format-btn');
            const yamlBtn = document.getElementById('yaml-format-btn');

            if (jsonBtn && yamlBtn) {
                jsonBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (jsonBtn.classList.contains('active')) return;
                    this.switchFormat(jsonBtn, yamlBtn, 'json', 'raw');
                });

                yamlBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (yamlBtn.classList.contains('active')) return;
                    this.switchFormat(yamlBtn, jsonBtn, 'yaml', 'raw');
                });
            }
        },

        initComponentsFormatSwitchers() {
            const jsonBtn = document.getElementById('components-json-format-btn');
            const yamlBtn = document.getElementById('components-yaml-format-btn');

            if (jsonBtn && yamlBtn) {
                jsonBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (jsonBtn.classList.contains('active')) return;
                    this.switchFormat(jsonBtn, yamlBtn, 'json', 'components');
                });

                yamlBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (yamlBtn.classList.contains('active')) return;
                    this.switchFormat(yamlBtn, jsonBtn, 'yaml', 'components');
                });
            }
        },

        initCopyButtons() {
            const rawCopyBtn = document.getElementById('copy-raw-schema-btn');
            const componentsCopyBtn = document.getElementById('copy-components-btn');

            if (rawCopyBtn) {
                rawCopyBtn.addEventListener('click', () => {
                    this.copyToClipboard('raw-schema-content', rawCopyBtn);
                });
            }

            if (componentsCopyBtn) {
                componentsCopyBtn.addEventListener('click', () => {
                    this.copyToClipboard('components-content', componentsCopyBtn);
                });
            }
        },

        switchFormat(activeBtn, inactiveBtn, format, type) {
            // Update button states
            activeBtn.classList.add('active');
            inactiveBtn.classList.remove('active');

            // Update content
            if (type === 'raw') {
                APILoader.updateRawSchema(format);
            } else if (type === 'components') {
                APILoader.updateComponents(format);
            }
        },

        copyToClipboard(contentElementId, buttonElement) {
            const content = document.getElementById(contentElementId);
            if (!content) return;

            const text = content.textContent || content.innerText;
            navigator.clipboard.writeText(text).then(() => {
                const originalHtml = buttonElement.innerHTML;
                buttonElement.innerHTML = '<i class="ri-check-line"></i> Copied!';
                buttonElement.classList.add('btn-success');
                buttonElement.classList.remove('btn-secondary');

                setTimeout(() => {
                    buttonElement.innerHTML = originalHtml;
                    buttonElement.classList.remove('btn-success');
                    buttonElement.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy content:', err);
                const originalHtml = buttonElement.innerHTML;
                buttonElement.innerHTML = '<i class="ri-close-line"></i> Failed';
                buttonElement.classList.add('btn-danger');
                buttonElement.classList.remove('btn-secondary');

                setTimeout(() => {
                    buttonElement.innerHTML = originalHtml;
                    buttonElement.classList.remove('btn-danger');
                    buttonElement.classList.add('btn-secondary');
                }, 2000);
            });
        }
    };
{{end}}
