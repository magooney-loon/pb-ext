{{define "api_loader_js"}}
    // =============================================================================
    // SIMPLIFIED API LOADER - FOR CLEAN OPENAPI BACKEND
    // =============================================================================

    const APILoader = {
        loadingState: {
            versions: false,
            endpoints: false
        },

        // Get superuser authentication token from localStorage
        getSuperuserAuthToken() {
            try {
                const authData = localStorage.getItem('__pb_superuser_auth__');
                if (!authData) {
                    return null;
                }

                const parsed = JSON.parse(authData);
                return parsed.token || null;
            } catch (error) {
                console.error('Failed to parse auth token:', error);
                return null;
            }
        },

        // Create authenticated fetch options
        getAuthenticatedFetchOptions(options = {}) {
            const token = this.getSuperuserAuthToken();
            if (!token) {
                throw new Error('SuperUser authentication required');
            }

            return {
                ...options,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            };
        },

        // Load available API versions
        async loadVersions() {
            if (this.loadingState.versions) {
                return;
            }

            this.loadingState.versions = true;

            try {
                this.updateStatus('loading', 'Loading API versions...');

                const response = await fetch('/api/docs/versions', this.getAuthenticatedFetchOptions());
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('SuperUser authentication required. Please log in as superuser.');
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (!data || !data.versions) {
                    throw new Error('Invalid response format from versions endpoint');
                }

                // Store version information
                APIState.availableVersions = data.versions;
                APIState.currentVersion = data.default_version || (data.versions.length > 0 ? data.versions[0].version : null);

                // Update UI
                this.populateVersionSelector();

                // Load the current version's endpoints
                if (APIState.currentVersion) {
                    await this.loadEndpoints();
                } else {
                    throw new Error('No API versions available');
                }

            } catch (error) {
                console.error('Failed to load API versions:', error);
                this.updateStatus('error', `Failed to load API versions: ${error.message}`);
                throw error;
            } finally {
                this.loadingState.versions = false;
            }
        },

        // Load OpenAPI spec for current version
        async loadEndpoints() {
            if (this.loadingState.endpoints) {
                return;
            }

            this.loadingState.endpoints = true;

            try {
                const version = APIState.currentVersion;
                if (!version) {
                    throw new Error('No current version selected');
                }

                this.updateStatus('loading', `Loading endpoints for version ${version}...`);

                const response = await fetch(`/api/docs/${version}`, this.getAuthenticatedFetchOptions());
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('SuperUser authentication required. Please log in as superuser.');
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const openApiSpec = await response.json();
                if (!openApiSpec || !openApiSpec.endpoints) {
                    throw new Error('Invalid OpenAPI specification received');
                }

                // Store the clean OpenAPI data - no conversion needed!
                APIState.openApiSchema = openApiSpec;
                APIState.allEndpoints = openApiSpec.endpoints;
                APIState.setEndpoints(openApiSpec.endpoints);

                // Update UI
                this.updateEndpointsList();
                this.updateStatsDisplay();
                this.updateVersionDisplay();
                this.initializeFilters();

                // Update other tabs with OpenAPI data
                this.updateRawSchema('json');
                this.updateComponents('json');

                this.updateStatus('success', `Loaded ${openApiSpec.endpoints.length} endpoints`);

            } catch (error) {
                console.error('Failed to load endpoints:', error);
                this.updateStatus('error', `Failed to load endpoints: ${error.message}`);
                throw error;
            } finally {
                this.loadingState.endpoints = false;
            }
        },

        // Switch to different API version
        async switchVersion(newVersion) {
            if (newVersion === APIState.currentVersion) {
                return;
            }

            APIState.currentVersion = newVersion;

            // Clear current data
            APIState.allEndpoints = [];
            APIState.filteredEndpoints = [];
            APIState.openApiSchema = null;

            // Load new version
            await this.loadEndpoints();
        },

        // Populate version selector dropdown
        populateVersionSelector() {
            const versionSelect = document.getElementById('version-select');
            if (!versionSelect || !APIState.availableVersions.length) {
                return;
            }

            versionSelect.innerHTML = '';

            APIState.availableVersions.forEach(versionInfo => {
                const option = document.createElement('option');
                option.value = versionInfo.version;

                // Enhanced display: show full title, version, and status
                const title = versionInfo.config?.title || 'API';
                const version = versionInfo.config?.version || versionInfo.version;
                const status = versionInfo.status || 'Active';
                const displayName = `${title} v${version} (${status})`;

                option.textContent = displayName;
                option.selected = versionInfo.version === APIState.currentVersion;
                versionSelect.appendChild(option);
            });

            // Add change event listener
            versionSelect.removeEventListener('change', this.handleVersionChange);
            versionSelect.addEventListener('change', this.handleVersionChange.bind(this));
        },

        // Handle version selection change
        async handleVersionChange(event) {
            const newVersion = event.target.value;
            if (newVersion && newVersion !== APIState.currentVersion) {
                try {
                    await this.switchVersion(newVersion);
                } catch (error) {
                    console.error('Failed to switch version:', error);
                    // Revert selection on error
                    event.target.value = APIState.currentVersion;
                }
            }
        },

        // Update endpoints list in UI
        updateEndpointsList() {
            if (typeof EndpointRenderer !== 'undefined' && EndpointRenderer.render) {
                EndpointRenderer.render();
            }
        },

        // Update statistics display
        updateStatsDisplay() {
            const stats = this.calculateStats();
            APIState.apiStats = stats;

            if (typeof UIController !== 'undefined' && UIController.updateStatistics) {
                UIController.updateStatistics(stats);
            }
        },

        // Update version display information
        updateVersionDisplay() {
            const versionInfo = APIState.availableVersions.find(v => v.version === APIState.currentVersion);
            if (!versionInfo) return;

            // Enhanced version display - update page title and add compact info
            const title = versionInfo.config?.title || 'API Documentation';
            const version = versionInfo.config?.version || versionInfo.version;
            const description = versionInfo.config?.description || '';

            // Update page title
            if (document.title.includes('API')) {
                document.title = `${title} v${version} - PocketBase`;
            }

            // Create/update compact API info display under version selector
            this.updateCompactAPIInfo(title, version, description);
        },

        // Update compact API information display
        updateCompactAPIInfo(title, version, description) {
            const versionSelect = document.getElementById('version-select');
            if (!versionSelect) return;

            // Look for existing info or create new one
            let infoDiv = document.getElementById('api-compact-info');

            if (!infoDiv) {
                infoDiv = document.createElement('div');
                infoDiv.id = 'api-compact-info';
                infoDiv.className = 'api-compact-info txt-sm txt-hint mt-2 mb-3';

                // Insert after the entire version selector container (flex container)
                const flexContainer = versionSelect.closest('.flex') || versionSelect.parentElement;
                flexContainer.parentElement.insertBefore(infoDiv, flexContainer.nextSibling);

                // Add minimal CSS
                if (!document.getElementById('api-compact-styles')) {
                    const style = document.createElement('style');
                    style.id = 'api-compact-styles';
                    style.textContent = `
                        .api-compact-info {
                            padding: 8px 12px !important;
                            background: #f8f9fa !important;
                            border-radius: 4px !important;
                            border-left: 3px solid #007bff !important;
                        }
                        .api-compact-desc {
                            color: #6c757d !important;
                            font-style: italic !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            // Update content - only show description
            if (description) {
                infoDiv.innerHTML = `<span class="api-compact-desc">${this._escapeHtml(description)}</span>`;
                infoDiv.style.display = 'block';
            } else {
                infoDiv.style.display = 'none';
            }
        },

        // Helper method to escape HTML
        _escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        // Initialize filter options
        initializeFilters() {
            if (typeof UIController !== 'undefined') {
                const stats = APIState.apiStats || this.calculateStats();
                if (UIController.populateFilterOptions) {
                    UIController.populateFilterOptions(stats);
                }

                // Show filters section
                const filtersSection = document.getElementById('api-filters');
                if (filtersSection) {
                    filtersSection.style.display = 'block';
                }
            }
        },

        // Update raw schema display
        updateRawSchema(format = 'json') {
            const rawContent = document.getElementById('raw-schema-content');
            if (!rawContent) {
                return;
            }

            if (!APIState.openApiSchema) {
                rawContent.innerHTML = '<code>No schema data available</code>';
                return;
            }

            try {
                // Use SchemaProcessor for syntax highlighting if available
                if (typeof SchemaProcessor !== 'undefined') {
                    // Pass the original JSON data to syntaxHighlight, let it handle the conversion
                    const highlighted = SchemaProcessor.syntaxHighlight(APIState.openApiSchema, format);
                    rawContent.innerHTML = highlighted;
                } else {
                    // Fallback for when SchemaProcessor is not available
                    let content;
                    if (format === 'yaml') {
                        content = 'YAML format not available without SchemaProcessor';
                    } else {
                        content = JSON.stringify(APIState.openApiSchema, null, 2);
                    }
                    rawContent.innerHTML = `<code>${this._escapeHtml(content)}</code>`;
                }

            } catch (error) {
                console.error('Failed to update raw schema:', error);
                rawContent.innerHTML = `<code class="txt-danger">Error formatting schema: ${error.message}</code>`;
            }
        },

        // Update components schema display
        updateComponents(format = 'json') {
            const componentsContent = document.getElementById('components-content');
            if (!componentsContent) {
                return;
            }

            if (!APIState.openApiSchema?.components || Object.keys(APIState.openApiSchema.components).length === 0) {
                componentsContent.innerHTML = '<code>No components available</code>';
                return;
            }

            try {
                // Use SchemaProcessor for syntax highlighting if available
                if (typeof SchemaProcessor !== 'undefined') {
                    // Pass the original JSON data to syntaxHighlight, let it handle the conversion
                    const highlighted = SchemaProcessor.syntaxHighlight(APIState.openApiSchema.components, format);
                    componentsContent.innerHTML = highlighted;
                } else {
                    // Fallback for when SchemaProcessor is not available
                    let content;
                    if (format === 'yaml') {
                        content = 'YAML format not available without SchemaProcessor';
                    } else {
                        content = JSON.stringify(APIState.openApiSchema.components, null, 2);
                    }
                    componentsContent.innerHTML = `<code>${this._escapeHtml(content)}</code>`;
                }

            } catch (error) {
                console.error('Failed to update components:', error);
                componentsContent.innerHTML = `<code class="txt-danger">Error formatting components: ${error.message}</code>`;
            }
        },

        // Helper method for HTML escaping
        _escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        // Calculate statistics from endpoints
        calculateStats() {
            const endpoints = APIState.allEndpoints || [];

            const stats = {
                totalEndpoints: endpoints.length,
                methods: {},
                tags: {},
                authTypes: {}
            };

            endpoints.forEach(endpoint => {
                // Count methods
                const method = endpoint.method || 'UNKNOWN';
                stats.methods[method] = (stats.methods[method] || 0) + 1;

                // Count tags
                (endpoint.tags || []).forEach(tag => {
                    stats.tags[tag] = (stats.tags[tag] || 0) + 1;
                });

                // Count auth types
                const authType = endpoint.auth?.type || 'none';
                stats.authTypes[authType] = (stats.authTypes[authType] || 0) + 1;
            });

            return stats;
        },



        // Update status message
        updateStatus(type, message) {
            if (typeof ErrorStatusManager !== 'undefined') {
                ErrorStatusManager.updateStatus(type, message);
            } else if (typeof StatusManager !== 'undefined') {
                StatusManager.updateStatus(type, message);
            }
        },

        // Check if currently loading
        isLoading() {
            return this.loadingState.versions || this.loadingState.endpoints;
        },

        // Initialize the API loader
        async initialize() {
            try {
                await this.loadVersions();
                return true;
            } catch (error) {
                console.error('Failed to initialize API loader:', error);
                return false;
            }
        },

        // DEBUG METHODS FOR TROUBLESHOOTING
        getDebugInfo() {
            return {
                timestamp: new Date().toISOString(),
                loading: {
                    versions: this.loadingState.versions,
                    endpoints: this.loadingState.endpoints
                },
                auth: {
                    hasToken: !!this.getSuperuserAuthToken(),
                    tokenPreview: this.getSuperuserAuthToken()?.substring(0, 20) + '...' || null
                },
                state: {
                    availableVersions: APIState.availableVersions?.length || 0,
                    currentVersion: APIState.currentVersion,
                    allEndpoints: APIState.allEndpoints?.length || 0,
                    filteredEndpoints: APIState.filteredEndpoints?.length || 0
                },
                components: {
                    APIState: typeof APIState,
                    UIController: typeof UIController,
                    EndpointRenderer: typeof EndpointRenderer,
                    ErrorStatusManager: typeof ErrorStatusManager
                },
                dom: {
                    versionSelect: !!document.getElementById('version-select'),
                    endpointsList: !!document.getElementById('endpoints-list'),
                    apiFilters: !!document.getElementById('api-filters')
                }
            };
        },

        async testConnection() {
            try {
                const response = await fetch('/api/docs/versions', this.getFetchOptions(false));
                const data = await response.json();
                return { success: true, status: response.status, data };
            } catch (error) {
                console.error('Connection test failed:', error);
                return { success: false, error: error.message };
            }
        },

        async forceReload() {
            this.loadingState.versions = false;
            this.loadingState.endpoints = false;
            APIState.reset();
            return await this.initialize();
        },

        checkDependencies() {
            const deps = {
                APIState: typeof APIState !== 'undefined',
                UIController: typeof UIController !== 'undefined',
                EndpointRenderer: typeof EndpointRenderer !== 'undefined',
                ErrorStatusManager: typeof ErrorStatusManager !== 'undefined'
            };

            const missing = Object.entries(deps).filter(([name, available]) => !available);

            if (missing.length > 0) {
                console.error('Missing dependencies:', missing.map(([name]) => name));
                return { success: false, missing: missing.map(([name]) => name) };
            } else {
                return { success: true };
            }
        }
    };

    // Export for global use
    if (typeof window !== 'undefined') {
        window.APILoader = APILoader;

        // Global debug helper for troubleshooting
        window.APIDebug = window.APIDebug || {};
        window.APIDebug.loader = {
            // Quick status check
            status: () => APILoader.getDebugInfo(),

            // Test API connection
            test: () => APILoader.testConnection(),

            // Force reload API data
            reload: () => APILoader.forceReload(),

            // Check component dependencies
            deps: () => APILoader.checkDependencies(),

            // Get auth token info
            auth: () => ({
                hasToken: !!APILoader.getSuperuserAuthToken(),
                tokenPreview: APILoader.getSuperuserAuthToken()?.substring(0, 20) + '...' || null
            }),

            // Manual initialization
            init: () => APILoader.initialize(),

            // Current state snapshot
            state: () => ({
                versions: APIState?.availableVersions || [],
                currentVersion: APIState?.currentVersion,
                endpoints: APIState?.allEndpoints?.length || 0,
                filtered: APIState?.filteredEndpoints?.length || 0
            })
        };
    }

{{end}}
