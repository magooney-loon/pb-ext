{{define "api_state_js"}}
    // =============================================================================
    // API STATE MANAGEMENT
    // =============================================================================

    const APIState = {
        openApiSchema: null,
        apiStats: null,
        apiComponents: null,
        allEndpoints: [],
        filteredEndpoints: [],
        availableVersions: [],
        currentVersion: null,
        schemaConfig: null,

        reset() {
            this.openApiSchema = null;
            this.apiStats = null;
            this.apiComponents = null;
            this.allEndpoints = [];
            this.filteredEndpoints = [];
            this.schemaConfig = null;
        },

        setEndpoints(endpoints) {
            this.allEndpoints = this.validateEndpoints(endpoints);
            this.filteredEndpoints = [...this.allEndpoints];
        },

        validateEndpoints(endpoints) {
            if (!Array.isArray(endpoints)) {
                console.warn('Expected endpoints array, got:', typeof endpoints, endpoints);
                return [];
            }

            return endpoints.map((endpoint, index) => {
                const validated = {
                    method: endpoint.method || 'GET',
                    path: endpoint.path || '/',
                    handler_name: endpoint.handler_name || `endpoint_${index}`,
                    description: endpoint.description || 'No description available',
                    tags: Array.isArray(endpoint.tags) ? endpoint.tags : [],
                    auth: this.validateAuthInfo(endpoint.auth),
                    request: endpoint.request || null,
                    response: endpoint.response || null
                };

                // Log validation warnings for debugging AST issues
                if (!endpoint.path) {
                    console.warn(`Endpoint ${index}: Missing path, using default`);
                }
                if (!endpoint.method) {
                    console.warn(`Endpoint ${index}: Missing method, using GET`);
                }

                return validated;
            });
        },

        validateAuthInfo(auth) {
            if (!auth) return { required: false };

            return {
                required: Boolean(auth.required),
                type: auth.type || 'unknown',
                description: auth.description || 'Authentication required',
                icon: auth.icon || 'ðŸ”',
                collections: Array.isArray(auth.collections) ? auth.collections : [],
                owner_param: auth.owner_param || null
            };
        },

        // Configuration cache with version-specific storage
        configCache: new Map(),
        configLoadPromises: new Map(),

        // Load schema configuration from server with enhanced caching
        async loadSchemaConfig(forceReload = false) {
            const version = this.currentVersion || 'v1';
            const cacheKey = `config_${version}`;

            // Return cached config if available and not forcing reload
            if (!forceReload && this.configCache.has(cacheKey)) {
                this.schemaConfig = this.configCache.get(cacheKey);
                console.log(`Using cached schema configuration for version ${version}`);
                return this.schemaConfig;
            }

            // If there's already a loading promise for this version, wait for it
            if (this.configLoadPromises.has(cacheKey)) {
                console.log(`Waiting for existing config load for version ${version}`);
                return await this.configLoadPromises.get(cacheKey);
            }

            // Create loading promise
            const loadPromise = this._loadSchemaConfigFromServer(version, cacheKey);
            this.configLoadPromises.set(cacheKey, loadPromise);

            try {
                const config = await loadPromise;
                this.schemaConfig = config;
                return config;
            } finally {
                // Clean up promise regardless of success/failure
                this.configLoadPromises.delete(cacheKey);
            }
        },

        // Internal method to load config from server
        async _loadSchemaConfigFromServer(version, cacheKey) {
            try {
                console.log(`Loading schema configuration for version ${version}...`);

                const response = await fetch(`/api/${version}/schema/config`);

                if (!response.ok) {
                    throw new Error(`Failed to load schema config: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                // Validate response structure
                if (!data.success || !data.config) {
                    throw new Error('Invalid schema configuration response format');
                }

                // Cache the configuration
                this.configCache.set(cacheKey, data.config);
                console.log(`Schema configuration loaded and cached for version ${version}:`, data.config);

                return data.config;
            } catch (error) {
                console.error(`Failed to load schema configuration for version ${version}:`, error);

                // Check if we have a fallback in cache from previous version
                const fallbackConfig = this._getFallbackConfig();

                if (fallbackConfig) {
                    console.warn('Using fallback configuration from cache');
                    return fallbackConfig;
                }

                // Last resort: hardcoded defaults
                const defaultConfig = {
                    system_fields: ['id', 'created_at', 'updated_at'],
                    default_parameter_type: 'string',
                    default_parameter_in: 'query',
                    default_content_type: 'application/json',
                    description_templates: {
                        path: 'Path parameter: {name}',
                        query: 'Query parameter: {name}',
                        header: 'Header parameter: {name}',
                        body: 'Request body parameter: {name}'
                    },
                    supported_content_types: ['application/json']
                };

                console.warn('Using hardcoded fallback configuration');
                return defaultConfig;
            }
        },

        // Get fallback configuration from cache
        _getFallbackConfig() {
            // Try to find any cached config as fallback
            for (const [key, config] of this.configCache.entries()) {
                if (config && typeof config === 'object') {
                    console.log(`Using cached config from ${key} as fallback`);
                    return config;
                }
            }
            return null;
        },

        // Clear configuration cache
        clearConfigCache() {
            this.configCache.clear();
            this.configLoadPromises.clear();
            this.schemaConfig = null;
            console.log('Schema configuration cache cleared');
        },

        // Get system fields list
        getSystemFields() {
            return this.schemaConfig?.system_fields || ['id', 'created_at', 'updated_at'];
        },

        // Get default parameter type
        getDefaultParameterType() {
            return this.schemaConfig?.default_parameter_type || 'string';
        },

        // Get default parameter location
        getDefaultParameterIn() {
            return this.schemaConfig?.default_parameter_in || 'query';
        },

        // Get default content type
        getDefaultContentType() {
            return this.schemaConfig?.default_content_type || 'application/json';
        },

        // Get description template for parameter type
        getDescriptionTemplate(paramType, paramName) {
            const templates = this.schemaConfig?.description_templates || {};
            const template = templates[paramType] || `${paramType} parameter: {name}`;
            return template.replace('{name}', paramName);
        },

        // Debug and status methods
        getConfigurationStatus() {
            const version = this.currentVersion || 'unknown';
            const cacheKey = `config_${version}`;

            return {
                version: version,
                configLoaded: !!this.schemaConfig,
                configCached: this.configCache.has(cacheKey),
                cacheSize: this.configCache.size,
                loadingInProgress: this.configLoadPromises.has(cacheKey),
                availableVersions: this.availableVersions.map(v => v.version),
                endpointsLoaded: this.allEndpoints.length,
                filteredEndpoints: this.filteredEndpoints.length,
                componentsLoaded: Object.keys(this.apiComponents || {}).length
            };
        },

        // Get detailed debug information
        getDebugInfo() {
            const status = this.getConfigurationStatus();

            return {
                ...status,
                schemaConfig: this.schemaConfig,
                cacheKeys: Array.from(this.configCache.keys()),
                loadingPromises: Array.from(this.configLoadPromises.keys()),
                stats: this.apiStats,
                lastError: this._lastError || null
            };
        },

        // Log current state for debugging
        logStatus() {
            const status = this.getConfigurationStatus();
            console.group('APIState Status');
            console.log('Configuration Status:', status);
            console.log('Schema Config:', this.schemaConfig);
            console.log('Cache Contents:', Array.from(this.configCache.entries()));
            console.groupEnd();
        },

        // Health check method
        isHealthy() {
            return {
                healthy: !!(this.schemaConfig && this.currentVersion && this.availableVersions.length > 0),
                issues: this._getHealthIssues()
            };
        },

        // Get health issues
        _getHealthIssues() {
            const issues = [];

            if (!this.schemaConfig) {
                issues.push('Schema configuration not loaded');
            }

            if (!this.currentVersion) {
                issues.push('No current API version selected');
            }

            if (!this.availableVersions || this.availableVersions.length === 0) {
                issues.push('No API versions available');
            }

            if (this.configLoadPromises.size > 0) {
                issues.push('Configuration loads still in progress');
            }

            return issues;
        }
    };

    // Expose global debug utilities
    window.APIStateDebug = {
        getStatus: () => APIState.getConfigurationStatus(),
        getDebugInfo: () => APIState.getDebugInfo(),
        logStatus: () => APIState.logStatus(),
        healthCheck: () => APIState.isHealthy(),
        clearCache: () => APIState.clearConfigCache(),
        reloadConfig: () => APIState.loadSchemaConfig(true)
    };
{{end}}
