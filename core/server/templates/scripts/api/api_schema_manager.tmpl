{{define "api_schema_manager_js"}}
    // =============================================================================
    // API SCHEMA MANAGER - SIMPLIFIED FOR AST-BASED SCHEMAS
    // =============================================================================

    const APISchemaManager = {
        // Extract request form fields from exact AST schema
        extractRequestFields(endpoint) {
            if (!endpoint || !endpoint.request || !endpoint.request.properties) {
                return [];
            }

            const fields = [];
            const schema = endpoint.request;
            const properties = schema.properties;
            const required = schema.required || [];

            for (const [fieldName, fieldSchema] of Object.entries(properties)) {
                fields.push({
                    name: fieldName,
                    type: fieldSchema.type, // Keep original schema type
                    inputType: this.mapSchemaType(fieldSchema.type), // Separate input type for UI
                    required: required.includes(fieldName),
                    description: fieldSchema.description,
                    example: fieldSchema.example || this.generateExample(fieldSchema.type),
                    format: fieldSchema.format,
                    enum: fieldSchema.enum,
                    minimum: fieldSchema.minimum,
                    maximum: fieldSchema.maximum,
                    pattern: fieldSchema.pattern
                });
            }

            return fields;
        },

        // Extract path parameters from endpoint path
        extractPathParameters(path) {
            const params = [];
            const pathParamRegex = /\{([^}]+)\}/g;
            let match;

            while ((match = pathParamRegex.exec(path)) !== null) {
                params.push({
                    name: match[1],
                    type: 'string',
                    required: true,
                    in: 'path',
                    description: `Path parameter: ${match[1]}`
                });
            }

            return params;
        },

        // Build complete parameter schema for forms
        buildParameterSchema(endpoint) {
            const pathParams = this.extractPathParameters(endpoint.path);
            const requestFields = this.extractRequestFields(endpoint);

            return {
                pathParameters: pathParams,
                bodyParameters: requestFields,
                queryParameters: [] // Can be manually added by user
            };
        },

        // Map JSON schema types to form input types
        mapSchemaType(schemaType) {
            const typeMap = {
                'string': 'text',
                'integer': 'number',
                'number': 'number',
                'boolean': 'checkbox',
                'array': 'text',
                'object': 'textarea'
            };

            return typeMap[schemaType] || 'text';
        },

        // Generate example value for schema type
        generateExample(schemaType) {
            const examples = {
                'string': 'example text',
                'integer': 42,
                'number': 3.14,
                'boolean': true,
                'array': '[]',
                'object': '{}'
            };

            return examples[schemaType] || '';
        },

        // Extract response schema info for display
        extractResponseInfo(endpoint) {
            if (!endpoint || !endpoint.response) {
                return {
                    hasSchema: false,
                    contentType: 'application/json',
                    description: 'No response schema available'
                };
            }

            const schema = endpoint.response;

            return {
                hasSchema: true,
                contentType: 'application/json',
                description: 'Response as defined by handler',
                schema: schema,
                required: schema.required || [],
                properties: schema.properties || {}
            };
        },

        // Validate request data against schema
        validateRequestData(endpoint, data) {
            const errors = [];

            if (!endpoint || !endpoint.request) {
                return { valid: true, errors: [] };
            }

            const schema = endpoint.request;
            const required = schema.required || [];
            const properties = schema.properties || {};

            // Check required fields
            for (const field of required) {
                if (!data || !data.hasOwnProperty(field) || data[field] === '' || data[field] === null) {
                    errors.push(`Required field '${field}' is missing or empty`);
                }
            }

            // Check field types
            for (const [fieldName, value] of Object.entries(data || {})) {
                const fieldSchema = properties[fieldName];
                if (fieldSchema && value !== '' && value !== null) {
                    const typeError = this.validateFieldType(fieldName, value, fieldSchema);
                    if (typeError) {
                        errors.push(typeError);
                    }
                }
            }

            return {
                valid: errors.length === 0,
                errors: errors
            };
        },

        // Validate individual field type
        validateFieldType(fieldName, value, fieldSchema) {
            const type = fieldSchema.type;

            switch (type) {
                case 'boolean':
                    if (typeof value !== 'boolean' && value !== 'true' && value !== 'false') {
                        return `Field '${fieldName}' must be a boolean (true/false)`;
                    }
                    break;

                case 'integer':
                case 'number':
                    const num = Number(value);
                    if (isNaN(num)) {
                        return `Field '${fieldName}' must be a number`;
                    }
                    if (type === 'integer' && !Number.isInteger(num)) {
                        return `Field '${fieldName}' must be an integer`;
                    }
                    if (fieldSchema.minimum !== undefined && num < fieldSchema.minimum) {
                        return `Field '${fieldName}' must be at least ${fieldSchema.minimum}`;
                    }
                    if (fieldSchema.maximum !== undefined && num > fieldSchema.maximum) {
                        return `Field '${fieldName}' must be at most ${fieldSchema.maximum}`;
                    }
                    break;

                case 'string':
                    if (typeof value !== 'string') {
                        return `Field '${fieldName}' must be a string`;
                    }
                    if (fieldSchema.pattern) {
                        const regex = new RegExp(fieldSchema.pattern);
                        if (!regex.test(value)) {
                            return `Field '${fieldName}' does not match required pattern`;
                        }
                    }
                    break;
            }

            return null;
        },

        // Format response for display
        formatResponse(responseData) {
            if (!responseData) {
                return 'No response data';
            }

            if (typeof responseData === 'string') {
                try {
                    responseData = JSON.parse(responseData);
                } catch (e) {
                    return responseData;
                }
            }

            return JSON.stringify(responseData, null, 2);
        },

        // Get content type for request
        getRequestContentType(endpoint) {
            if (!endpoint || !endpoint.request) {
                return 'application/json';
            }

            // Always use JSON for our AST-generated schemas
            return 'application/json';
        },

        // Build URL with path parameters
        buildUrl(endpoint, pathParams = {}) {
            let url = endpoint.path;

            // Replace path parameters
            for (const [key, value] of Object.entries(pathParams)) {
                url = url.replace(`{${key}}`, encodeURIComponent(value));
            }

            return url;
        },

        // Extract available filters from response schema
        extractAvailableFilters(endpoint) {
            if (!endpoint || !endpoint.response || !endpoint.response.properties) {
                return [];
            }

            const responseSchema = endpoint.response;
            const filtersProperty = responseSchema.properties.filters;

            if (!filtersProperty || !filtersProperty.properties) {
                return [];
            }

            const filters = [];
            const filterProperties = filtersProperty.properties;
            const requiredFilters = filtersProperty.required || [];

            for (const [filterName, filterSchema] of Object.entries(filterProperties)) {
                filters.push({
                    name: filterName,
                    type: filterSchema.type || 'string',
                    required: requiredFilters.includes(filterName),
                    description: filterSchema.description || `Filter by ${filterName}`,
                    example: filterSchema.example || this.generateFilterExample(filterSchema.type, filterName),
                    enum: filterSchema.enum
                });
            }

            return filters;
        },

        // Generate example values for filter fields
        generateFilterExample(type, name) {
            const commonFilters = {
                'completed': 'true',
                'priority': 'high',
                'status': 'active',
                'type': 'task',
                'category': 'work',
                'date': '2024-01-01',
                'limit': '10',
                'offset': '0',
                'sort': 'created_at',
                'order': 'desc'
            };

            if (commonFilters[name.toLowerCase()]) {
                return commonFilters[name.toLowerCase()];
            }

            switch (type) {
                case 'boolean':
                    return 'true';
                case 'integer':
                case 'number':
                    return '10';
                case 'string':
                default:
                    return 'example';
            }
        },

        // Prepare request body from form data
        prepareRequestBody(endpoint, formData) {
            if (!endpoint || !endpoint.request || !formData) {
                return null;
            }

            const body = {};
            const properties = endpoint.request.properties || {};

            for (const [fieldName, fieldSchema] of Object.entries(properties)) {
                if (formData.hasOwnProperty(fieldName)) {
                    let value = formData[fieldName];

                    // Convert types based on schema
                    switch (fieldSchema.type) {
                        case 'boolean':
                            body[fieldName] = value === 'true' || value === true;
                            break;
                        case 'integer':
                            body[fieldName] = parseInt(value, 10);
                            break;
                        case 'number':
                            body[fieldName] = parseFloat(value);
                            break;
                        default:
                            body[fieldName] = value;
                    }
                }
            }

            return body;
        }
    };
{{end}}
