{{define "api_schema_manager_js"}}
    // =============================================================================
    // SIMPLIFIED API SCHEMA MANAGER - FOR CLEAN OPENAPI BACKEND
    // =============================================================================

    const APISchemaManager = {

        // Extract form fields directly from OpenAPI request schema
        extractRequestFields(endpoint) {
            if (!endpoint?.request?.properties) {
                return [];
            }

            const fields = [];
            const schema = endpoint.request;
            const required = schema.required || [];

            Object.entries(schema.properties).forEach(([fieldName, fieldSchema]) => {
                fields.push({
                    name: fieldName,
                    type: fieldSchema.type,
                    inputType: this.getInputType(fieldSchema),
                    required: required.includes(fieldName),
                    description: fieldSchema.description || '',
                    example: fieldSchema.example,
                    format: fieldSchema.format,
                    enum: fieldSchema.enum,
                    minimum: fieldSchema.minimum,
                    maximum: fieldSchema.maximum,
                    minLength: fieldSchema.minLength,
                    maxLength: fieldSchema.maxLength,
                    pattern: fieldSchema.pattern,
                    default: fieldSchema.default
                });
            });

            return fields;
        },

        // Extract path parameters from endpoint
        extractPathParameters(endpoint) {
            const pathParams = [];

            // Use OpenAPI parameters if available
            if (endpoint.parameters) {
                endpoint.parameters.forEach(param => {
                    if (param.in === 'path') {
                        pathParams.push({
                            name: param.name,
                            type: param.schema?.type || 'string',
                            required: param.required !== false,
                            description: param.description || `Path parameter: ${param.name}`,
                            example: param.schema?.example || param.example
                        });
                    }
                });
            } else {
                // Fallback: extract from path pattern
                const pathParamRegex = /\{([^}]+)\}/g;
                let match;
                while ((match = pathParamRegex.exec(endpoint.path)) !== null) {
                    pathParams.push({
                        name: match[1],
                        type: 'string',
                        required: true,
                        description: `Path parameter: ${match[1]}`,
                        example: 'example-value'
                    });
                }
            }

            return pathParams;
        },

        // Build complete parameter schema for forms
        buildParameterSchema(endpoint) {
            return {
                pathParameters: this.extractPathParameters(endpoint),
                bodyParameters: this.extractRequestFields(endpoint),
                queryParameters: this.extractQueryParameters(endpoint)
            };
        },

        // Extract query parameters from endpoint
        extractQueryParameters(endpoint) {
            if (!endpoint.parameters) {
                return [];
            }

            return endpoint.parameters
                .filter(param => param.in === 'query')
                .map(param => ({
                    name: param.name,
                    type: param.schema?.type || 'string',
                    required: param.required === true,
                    description: param.description || `Query parameter: ${param.name}`,
                    example: param.schema?.example || param.example,
                    enum: param.schema?.enum,
                    default: param.schema?.default
                }));
        },

        // Map OpenAPI schema type to HTML input type
        getInputType(schema) {
            if (schema.enum) {
                return 'select';
            }

            switch (schema.type) {
                case 'string':
                    if (schema.format === 'email') return 'email';
                    if (schema.format === 'password') return 'password';
                    if (schema.format === 'date') return 'date';
                    if (schema.format === 'date-time') return 'datetime-local';
                    if (schema.format === 'uri') return 'url';
                    return schema.maxLength && schema.maxLength > 100 ? 'textarea' : 'text';
                case 'integer':
                case 'number':
                    return 'number';
                case 'boolean':
                    return 'checkbox';
                case 'array':
                    return 'textarea';
                case 'object':
                    return 'textarea';
                default:
                    return 'text';
            }
        },

        // Get response information directly from OpenAPI schema
        getResponseInfo(endpoint) {
            if (!endpoint?.response) {
                return {
                    hasSchema: false,
                    contentType: 'application/json',
                    description: 'No response schema available',
                    schema: null
                };
            }

            return {
                hasSchema: true,
                contentType: 'application/json',
                description: endpoint.response.description || 'Response from endpoint',
                schema: endpoint.response,
                properties: endpoint.response.properties || {},
                required: endpoint.response.required || []
            };
        },

        // Simple validation using OpenAPI schema constraints
        validateRequestData(endpoint, data) {
            const errors = [];

            if (!endpoint?.request?.properties) {
                return { valid: true, errors: [] };
            }

            const schema = endpoint.request;
            const required = schema.required || [];

            // Check required fields
            required.forEach(fieldName => {
                if (!data || !(fieldName in data) || data[fieldName] === '' || data[fieldName] === null || data[fieldName] === undefined) {
                    errors.push(`Required field '${fieldName}' is missing or empty`);
                }
            });

            // Basic type and constraint validation
            Object.entries(data || {}).forEach(([fieldName, value]) => {
                const fieldSchema = schema.properties[fieldName];
                if (fieldSchema && value !== '' && value != null) {
                    const error = this.validateField(fieldName, value, fieldSchema);
                    if (error) {
                        errors.push(error);
                    }
                }
            });

            return {
                valid: errors.length === 0,
                errors: errors
            };
        },

        // Validate individual field against its OpenAPI schema
        validateField(fieldName, value, schema) {
            // Type validation
            switch (schema.type) {
                case 'integer':
                    const intVal = parseInt(value, 10);
                    if (isNaN(intVal)) {
                        return `Field '${fieldName}' must be an integer`;
                    }
                    value = intVal;
                    break;
                case 'number':
                    const numVal = parseFloat(value);
                    if (isNaN(numVal)) {
                        return `Field '${fieldName}' must be a number`;
                    }
                    value = numVal;
                    break;
                case 'boolean':
                    if (typeof value === 'string') {
                        if (!['true', 'false', '1', '0'].includes(value.toLowerCase())) {
                            return `Field '${fieldName}' must be a boolean (true/false)`;
                        }
                    }
                    break;
            }

            // Constraint validation
            if (schema.minimum !== undefined && value < schema.minimum) {
                return `Field '${fieldName}' must be at least ${schema.minimum}`;
            }
            if (schema.maximum !== undefined && value > schema.maximum) {
                return `Field '${fieldName}' must be at most ${schema.maximum}`;
            }
            if (schema.minLength !== undefined && value.length < schema.minLength) {
                return `Field '${fieldName}' must be at least ${schema.minLength} characters`;
            }
            if (schema.maxLength !== undefined && value.length > schema.maxLength) {
                return `Field '${fieldName}' must be at most ${schema.maxLength} characters`;
            }
            if (schema.pattern) {
                const regex = new RegExp(schema.pattern);
                if (!regex.test(value)) {
                    return `Field '${fieldName}' does not match required pattern`;
                }
            }
            if (schema.enum && !schema.enum.includes(value)) {
                return `Field '${fieldName}' must be one of: ${schema.enum.join(', ')}`;
            }

            return null;
        },

        // Format response data for display
        formatResponse(responseData) {
            if (!responseData) {
                return 'No response data';
            }

            if (typeof responseData === 'string') {
                try {
                    responseData = JSON.parse(responseData);
                } catch (e) {
                    return responseData;
                }
            }

            return JSON.stringify(responseData, null, 2);
        },

        // Build URL with path parameters substituted
        buildUrl(endpoint, pathParams = {}) {
            let url = endpoint.path;

            // Replace path parameters
            Object.entries(pathParams).forEach(([key, value]) => {
                url = url.replace(`{${key}}`, encodeURIComponent(value));
            });

            return url;
        },

        // Prepare request body from form data according to schema
        prepareRequestBody(endpoint, formData) {
            if (!endpoint?.request?.properties || !formData) {
                return null;
            }

            const body = {};
            const properties = endpoint.request.properties;

            Object.entries(properties).forEach(([fieldName, fieldSchema]) => {
                if (fieldName in formData && formData[fieldName] !== '') {
                    let value = formData[fieldName];

                    // Convert value according to schema type
                    switch (fieldSchema.type) {
                        case 'boolean':
                            body[fieldName] = value === 'true' || value === true || value === '1';
                            break;
                        case 'integer':
                            body[fieldName] = parseInt(value, 10);
                            break;
                        case 'number':
                            body[fieldName] = parseFloat(value);
                            break;
                        case 'array':
                            try {
                                body[fieldName] = typeof value === 'string' ? JSON.parse(value) : value;
                            } catch (e) {
                                body[fieldName] = value.split(',').map(s => s.trim());
                            }
                            break;
                        case 'object':
                            try {
                                body[fieldName] = typeof value === 'string' ? JSON.parse(value) : value;
                            } catch (e) {
                                body[fieldName] = value;
                            }
                            break;
                        default:
                            body[fieldName] = value;
                    }
                }
            });

            return Object.keys(body).length > 0 ? body : null;
        },

        // Get content type for request (always JSON for our OpenAPI endpoints)
        getRequestContentType() {
            return 'application/json';
        },

        // Check if endpoint requires authentication
        requiresAuth(endpoint) {
            return endpoint?.auth?.required === true;
        },

        // Get authentication info
        getAuthInfo(endpoint) {
            if (!endpoint?.auth) {
                return { required: false, type: 'none', description: 'No authentication required' };
            }

            return {
                required: endpoint.auth.required || false,
                type: endpoint.auth.type || 'none',
                description: endpoint.auth.description || 'Authentication required',
                icon: endpoint.auth.icon || (endpoint.auth.required ? '🔒' : '🌐')
            };
        },

        // Get example request body
        getExampleRequest(endpoint) {
            if (!endpoint?.request) {
                return null;
            }

            const example = {};
            const properties = endpoint.request.properties || {};

            Object.entries(properties).forEach(([fieldName, fieldSchema]) => {
                if (fieldSchema.example !== undefined) {
                    example[fieldName] = fieldSchema.example;
                } else if (fieldSchema.default !== undefined) {
                    example[fieldName] = fieldSchema.default;
                }
            });

            return Object.keys(example).length > 0 ? example : null;
        },

        // Check if endpoint has request body
        hasRequestBody(endpoint) {
            return endpoint?.request?.properties && Object.keys(endpoint.request.properties).length > 0;
        },

        // Check if endpoint has response schema
        hasResponseSchema(endpoint) {
            return endpoint?.response?.properties && Object.keys(endpoint.response.properties).length > 0;
        }
    };

    // Export for global use
    if (typeof window !== 'undefined') {
        window.APISchemaManager = APISchemaManager;
    }

{{end}}
