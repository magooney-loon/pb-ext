{{define "api_schema_manager_js"}}
    // =============================================================================
    // API SCHEMA MANAGER - SCHEMA EXTRACTION AND PROCESSING
    // =============================================================================

    const APISchemaManager = {


        // Extract parameter schema from endpoint data
        extractParameterSchema(endpoint) {

            console.log('[Schema Debug] extractParameterSchema called for endpoint:', endpoint);

            const schema = {
                pathParameters: [],
                queryParameters: [],
                headerParameters: [],
                requestBody: null,
                examples: {}
            };

            // Extract from OpenAPI endpoint data if available
            if (endpoint.data) {
                const endpointData = endpoint.data;


                // Extract path parameters from the path itself if not explicitly defined
                const pathParams = this.extractPathParameters(endpoint.path);
                console.log('[Schema Debug] Extracted path parameters from URL:', pathParams);
                if (pathParams.length > 0 && (!endpointData.parameters || endpointData.parameters.length === 0)) {
                    console.log('[Schema Debug] Using extracted path parameters since no explicit parameters found');
                    schema.pathParameters = pathParams;
                }

                // Extract parameters
                if (endpointData.parameters && Array.isArray(endpointData.parameters)) {
                    console.log('[Schema Debug] Processing explicit parameters:', endpointData.parameters);

                    endpointData.parameters.forEach((param, index) => {
                        console.log(`[Schema Debug] Processing parameter ${index}:`, param);

                        const normalizedParam = this.normalizeParameter(param);
                        console.log(`[Schema Debug] Normalized parameter:`, normalizedParam);

                        switch (param.in) {
                            case 'path':
                                schema.pathParameters.push(normalizedParam);
                                console.log('[Schema Debug] Added to path parameters');
                                break;
                            case 'query':
                                schema.queryParameters.push(normalizedParam);
                                console.log('[Schema Debug] Added to query parameters');
                                break;
                            case 'header':
                                schema.headerParameters.push(normalizedParam);
                                console.log('[Schema Debug] Added to header parameters');
                                break;
                        }
                    });
                } else if (schema.pathParameters.length === 0) {
                    console.log('[Schema Debug] No explicit parameters found and no path parameters extracted');
                }

                // For POST/PUT/PATCH methods, ALWAYS infer request body from response schema
                if (['POST', 'PUT', 'PATCH'].includes(endpoint.method)) {

                    schema.requestBody = this.inferRequestBodyFromResponse(endpointData.response);
                    if (schema.requestBody) {

                    } else {

                    }
                } else {

                }

                // Extract examples
                if (endpointData.examples) {
                    schema.examples = endpointData.examples;

                }
            } else {

            }

            console.log('[Schema Debug] Final extracted schema:', schema);

            return schema;
        },

        // Extract path parameters from URL path
        extractPathParameters(path) {
            console.log('[Schema Debug] extractPathParameters called with path:', path);
            const params = [];
            const regex = /{([^}]+)}/g;
            let match;

            while ((match = regex.exec(path)) !== null) {
                console.log('[Schema Debug] Found path parameter match:', match[1]);
                params.push({
                    name: match[1],
                    type: 'string',
                    required: true,
                    description: `Path parameter: ${match[1]}`,
                    example: '',
                    enum: null,
                    format: null,
                    in: 'path'
                });
            }

            console.log('[Schema Debug] Final extracted path parameters:', params);
            return params;
        },

        // Normalize parameter object
        normalizeParameter(param) {


            const normalized = {
                name: param.name || 'unknown',
                type: param.schema?.type || param.type || 'string',
                required: param.required || false,
                description: param.description || `${param.in} parameter`,
                example: param.example || param.schema?.example || '',
                enum: param.schema?.enum || param.enum || null,
                format: param.schema?.format || param.format || null,
                in: param.in || 'query'
            };


            return normalized;
        },

        // Infer request body schema ONLY from response
        inferRequestBodyFromResponse(responseSchema) {

            console.log('[Schema Debug] inferRequestBodyFromResponse called with:', responseSchema);

            if (!responseSchema) {
                console.log('[Schema Debug] No response schema provided, using default');
                return this.getDefaultRequestBody();
            }

            // Priority order for finding the main data structure in response
            const dataKeys = ['data', 'post', 'item', 'resource', 'result', 'object', 'entity', 'record'];
            let resourceSchema = null;

            // First, try to find a nested data object in the response
            if (responseSchema.properties) {
                console.log('[Schema Debug] Response has properties:', Object.keys(responseSchema.properties));
                for (const key of dataKeys) {
                    if (responseSchema.properties[key] && responseSchema.properties[key].properties) {
                        resourceSchema = responseSchema.properties[key];
                        console.log('[Schema Debug] Found nested data object under key:', key);
                        break;
                    }
                }

                // If no nested object found but response has properties, use response directly
                if (!resourceSchema && Object.keys(responseSchema.properties).length > 0) {
                    console.log('[Schema Debug] No nested data object found, using response schema directly');
                    resourceSchema = responseSchema;
                }
            }

            // If response is an array, look at the items schema
            if (!resourceSchema && responseSchema.type === 'array' && responseSchema.items) {
                console.log('[Schema Debug] Response is array, using items schema:', responseSchema.items);
                resourceSchema = responseSchema.items;
            }

            if (resourceSchema) {
                console.log('[Schema Debug] Found resource schema:', resourceSchema);
                // Clean the schema by removing server-generated fields
                const cleanedSchema = this.cleanSchemaForRequest(resourceSchema);
                console.log('[Schema Debug] Cleaned schema:', cleanedSchema);

                return {
                    type: 'object',
                    required: true,
                    schema: cleanedSchema,
                    description: 'Request payload (inferred from response structure)'
                };
            }

            console.log('[Schema Debug] No resource schema found, using default request body');
            return this.getDefaultRequestBody();
        },

        // Get default request body when inference fails
        getDefaultRequestBody() {
            return {
                type: 'object',
                required: true,
                schema: {
                    type: 'object',
                    properties: {},
                    additionalProperties: true
                },
                description: 'Request payload (using flexible schema)'
            };
        },

        // Clean schema for request by removing server-generated fields
        cleanSchemaForRequest(schema) {
            if (!schema) return schema;

            console.log('[Schema Debug] cleanSchemaForRequest called with schema:', schema);

            // Expanded list of server-generated fields to exclude
            const excludeFields = [
                'id', '_id', 'uid', 'uuid',
                'created', 'created_at', 'created_by', 'created_date', 'creation_time',
                'updated', 'updated_at', 'updated_by', 'updated_date', 'modification_time',
                'modified', 'modified_at', 'modified_by', 'last_modified',
                'deleted', 'deleted_at', 'deleted_by',
                'author', 'author_id', 'user', 'user_id', 'owner', 'owner_id',
                'creator', 'creator_id', 'modifier', 'modifier_id',
                'version', 'revision', 'etag', 'timestamp'
            ];

            // If schema has properties, filter them
            if (schema.properties) {
                console.log('[Schema Debug] Processing schema properties:', Object.keys(schema.properties));
                const cleanedProperties = {};

                Object.entries(schema.properties).forEach(([key, value]) => {
                    const lowerKey = key.toLowerCase();
                    const shouldExclude = excludeFields.some(field =>
                        lowerKey === field ||
                        lowerKey === `${field}_id` ||
                        lowerKey.endsWith(`_${field}`)
                    );

                    console.log(`[Schema Debug] Processing field: ${key}, type: ${value.type}, shouldExclude: ${shouldExclude}`, value);

                    if (!shouldExclude) {
                        cleanedProperties[key] = value;
                        console.log(`[Schema Debug] Kept field: ${key} with type: ${value.type}`);
                    } else {
                        console.log(`[Schema Debug] Excluded field: ${key}`);
                    }
                });

                return {
                    ...schema,
                    properties: cleanedProperties,
                    required: schema.required ? schema.required.filter(field =>
                        !excludeFields.some(exclude => field.toLowerCase() === exclude)
                    ) : []
                };
            }

            return schema;
        }
    };
{{end}}
