{{define "api_schema_manager_js"}}
    // =============================================================================
    // API SCHEMA MANAGER - SCHEMA EXTRACTION AND PROCESSING
    // =============================================================================

    const APISchemaManager = {
        debug: true,

        // Debug logging
        log(...args) {
            if (this.debug) {
                console.log('[APISchemaManager]', ...args);
            }
        },

        // Extract parameter schema from endpoint data
        extractParameterSchema(endpoint) {
            this.log('Starting parameter schema extraction for:', endpoint.method, endpoint.path);

            const schema = {
                pathParameters: [],
                queryParameters: [],
                headerParameters: [],
                requestBody: null,
                examples: {}
            };

            // Extract from OpenAPI endpoint data if available
            if (endpoint.data) {
                const endpointData = endpoint.data;
                this.log('Processing endpoint data:', endpointData);

                // Extract path parameters from the path itself if not explicitly defined
                const pathParams = this.extractPathParameters(endpoint.path);
                if (pathParams.length > 0 && (!endpointData.parameters || endpointData.parameters.length === 0)) {
                    this.log('Inferred path parameters from path:', pathParams);
                    schema.pathParameters = pathParams;
                }

                // Extract parameters
                if (endpointData.parameters && Array.isArray(endpointData.parameters)) {
                    this.log('Found parameters array:', endpointData.parameters);

                    endpointData.parameters.forEach((param, index) => {
                        this.log(`Processing parameter ${index}:`, param);

                        const normalizedParam = this.normalizeParameter(param);
                        this.log(`Normalized parameter ${index}:`, normalizedParam);

                        switch (param.in) {
                            case 'path':
                                schema.pathParameters.push(normalizedParam);
                                this.log('Added to path parameters');
                                break;
                            case 'query':
                                schema.queryParameters.push(normalizedParam);
                                this.log('Added to query parameters');
                                break;
                            case 'header':
                                schema.headerParameters.push(normalizedParam);
                                this.log('Added to header parameters');
                                break;
                        }
                    });
                } else if (schema.pathParameters.length === 0) {
                    this.log('No parameters found in endpoint data');
                }

                // For POST/PUT/PATCH methods, ALWAYS infer request body from response schema
                if (['POST', 'PUT', 'PATCH'].includes(endpoint.method)) {
                    this.log('Inferring request body from response schema for', endpoint.method);
                    schema.requestBody = this.inferRequestBodyFromResponse(endpointData.response);
                    if (schema.requestBody) {
                        this.log('Successfully inferred request body schema from response');
                    } else {
                        this.log('Could not infer request body from response, will use defaults');
                    }
                } else {
                    this.log('No request body needed for', endpoint.method);
                }

                // Extract examples
                if (endpointData.examples) {
                    schema.examples = endpointData.examples;
                    this.log('Found examples:', schema.examples);
                }
            } else {
                this.log('No endpoint data available');
            }

            this.log('Final extracted schema:', schema);
            return schema;
        },

        // Extract path parameters from URL path
        extractPathParameters(path) {
            const params = [];
            const regex = /{([^}]+)}/g;
            let match;

            while ((match = regex.exec(path)) !== null) {
                params.push({
                    name: match[1],
                    type: 'string',
                    required: true,
                    description: `Path parameter: ${match[1]}`,
                    example: '',
                    enum: null,
                    format: null,
                    in: 'path'
                });
            }

            return params;
        },

        // Normalize parameter object
        normalizeParameter(param) {
            this.log('Normalizing parameter:', param);

            const normalized = {
                name: param.name || 'unknown',
                type: param.schema?.type || param.type || 'string',
                required: param.required || false,
                description: param.description || `${param.in} parameter`,
                example: param.example || param.schema?.example || '',
                enum: param.schema?.enum || param.enum || null,
                format: param.schema?.format || param.format || null,
                in: param.in || 'query'
            };

            this.log('Normalized result:', normalized);
            return normalized;
        },

        // Infer request body schema ONLY from response
        inferRequestBodyFromResponse(responseSchema) {
            this.log('Inferring request body ONLY from response schema:', responseSchema);

            if (!responseSchema) {
                this.log('No response schema available for inference');
                return this.getDefaultRequestBody();
            }

            // Priority order for finding the main data structure in response
            const dataKeys = ['data', 'post', 'item', 'resource', 'result', 'object', 'entity', 'record'];
            let resourceSchema = null;

            // First, try to find a nested data object in the response
            if (responseSchema.properties) {
                for (const key of dataKeys) {
                    if (responseSchema.properties[key] && responseSchema.properties[key].properties) {
                        resourceSchema = responseSchema.properties[key];
                        this.log(`Found nested resource schema under '${key}':`, resourceSchema);
                        break;
                    }
                }

                // If no nested object found but response has properties, use response directly
                if (!resourceSchema && Object.keys(responseSchema.properties).length > 0) {
                    this.log('Using response properties directly for inference');
                    resourceSchema = responseSchema;
                }
            }

            // If response is an array, look at the items schema
            if (!resourceSchema && responseSchema.type === 'array' && responseSchema.items) {
                this.log('Response is an array, using items schema');
                resourceSchema = responseSchema.items;
            }

            if (resourceSchema) {
                // Clean the schema by removing server-generated fields
                const cleanedSchema = this.cleanSchemaForRequest(resourceSchema);

                return {
                    type: 'object',
                    required: true,
                    schema: cleanedSchema,
                    description: 'Request payload (inferred from response structure)'
                };
            }

            this.log('Could not infer schema from response, using defaults');
            return this.getDefaultRequestBody();
        },

        // Get default request body when inference fails
        getDefaultRequestBody() {
            return {
                type: 'object',
                required: true,
                schema: {
                    type: 'object',
                    properties: {},
                    additionalProperties: true
                },
                description: 'Request payload (using flexible schema)'
            };
        },

        // Clean schema for request by removing server-generated fields
        cleanSchemaForRequest(schema) {
            if (!schema) return schema;

            // Expanded list of server-generated fields to exclude
            const excludeFields = [
                'id', '_id', 'uid', 'uuid',
                'created', 'created_at', 'created_by', 'created_date', 'creation_time',
                'updated', 'updated_at', 'updated_by', 'updated_date', 'modification_time',
                'modified', 'modified_at', 'modified_by', 'last_modified',
                'deleted', 'deleted_at', 'deleted_by',
                'author', 'author_id', 'user', 'user_id', 'owner', 'owner_id',
                'creator', 'creator_id', 'modifier', 'modifier_id',
                'version', 'revision', 'etag', 'timestamp'
            ];

            // If schema has properties, filter them
            if (schema.properties) {
                const cleanedProperties = {};

                Object.entries(schema.properties).forEach(([key, value]) => {
                    const lowerKey = key.toLowerCase();
                    const shouldExclude = excludeFields.some(field =>
                        lowerKey === field ||
                        lowerKey === `${field}_id` ||
                        lowerKey.endsWith(`_${field}`)
                    );

                    if (!shouldExclude) {
                        cleanedProperties[key] = value;
                        this.log(`Including field: ${key}`);
                    } else {
                        this.log(`Excluding server-generated field: ${key}`);
                    }
                });

                return {
                    ...schema,
                    properties: cleanedProperties,
                    required: schema.required ? schema.required.filter(field =>
                        !excludeFields.some(exclude => field.toLowerCase() === exclude)
                    ) : []
                };
            }

            return schema;
        }
    };
{{end}}
