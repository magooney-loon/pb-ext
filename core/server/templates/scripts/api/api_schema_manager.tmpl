{{define "api_schema_manager_js"}}
    // =============================================================================
    // API SCHEMA MANAGER - SCHEMA EXTRACTION AND PROCESSING
    // =============================================================================

    const APISchemaManager = {


        // Extract parameter schema from endpoint data
        extractParameterSchema(endpoint) {

            const schema = {
                pathParameters: [],
                queryParameters: [],
                headerParameters: [],
                requestBody: null,
                examples: {}
            };

            // Extract from OpenAPI endpoint data if available
            if (endpoint.data) {
                const endpointData = endpoint.data;


                // Extract path parameters from the path itself if not explicitly defined
                const pathParams = this.extractPathParameters(endpoint.path);
                if (pathParams.length > 0 && (!endpointData.parameters || endpointData.parameters.length === 0)) {
                    schema.pathParameters = pathParams;
                }

                // Extract parameters
                if (endpointData.parameters && Array.isArray(endpointData.parameters)) {

                    endpointData.parameters.forEach((param, index) => {

                        const normalizedParam = this.normalizeParameter(param);

                        switch (param.in) {
                            case 'path':
                                schema.pathParameters.push(normalizedParam);
                                break;
                            case 'query':
                                schema.queryParameters.push(normalizedParam);
                                break;
                            case 'header':
                                schema.headerParameters.push(normalizedParam);
                                break;
                        }
                    });
                }

                // For POST/PUT/PATCH methods, use actual request schema or fallback to response inference
                if (['POST', 'PUT', 'PATCH'].includes(endpoint.method)) {

                    // First priority: Use actual request schema from AST analysis
                    if (endpointData.request) {
                        schema.requestBody = {
                            schema: endpointData.request,
                            required: true,
                            contentType: 'application/json'
                        };
                    }
                    // Fallback: Infer from response schema (legacy behavior)
                    else {
                        schema.requestBody = this.inferRequestBodyFromResponse(endpointData.response);
                    }
                }

                // Extract examples
                if (endpointData.examples) {
                    schema.examples = endpointData.examples;

                }
            } else {

            }

            return schema;
        },

        // Extract path parameters from URL path
        extractPathParameters(path) {
            const params = [];
            const regex = /{([^}]+)}/g;
            let match;

            while ((match = regex.exec(path)) !== null) {
                params.push({
                    name: match[1],
                    type: 'string',
                    required: true,
                    description: `Path parameter: ${match[1]}`,
                    example: '',
                    enum: null,
                    format: null,
                    in: 'path'
                });
            }

            return params;
        },

        // Normalize parameter object
        normalizeParameter(param) {


            const normalized = {
                name: param.name || 'unknown',
                type: param.schema?.type || param.type || 'string',
                required: param.required || false,
                description: param.description || `${param.in} parameter`,
                example: param.example || param.schema?.example || '',
                enum: param.schema?.enum || param.enum || null,
                format: param.schema?.format || param.format || null,
                in: param.in || 'query'
            };


            return normalized;
        },

        // Infer request body schema ONLY from response
        inferRequestBodyFromResponse(responseSchema) {

            if (!responseSchema) {
                return this.getDefaultRequestBody();
            }

            // Dynamic detection of data structure in response
            let resourceSchema = null;

            // First, try to find a nested data object in the response
            if (responseSchema.properties) {

                // Fields to exclude when looking for data objects (these are metadata, not data)
                const excludeKeys = ['message', 'error', 'errors', 'status', 'code', 'success', 'timestamp', 'meta', 'metadata'];

                // Look for any property that looks like data (purely dynamic detection)
                for (const [key, value] of Object.entries(responseSchema.properties)) {
                    // Skip excluded fields
                    if (excludeKeys.includes(key.toLowerCase())) {
                        continue;
                    }

                    // Look for objects with properties (potential data objects)
                    if (value.type === 'object' && value.properties) {
                        resourceSchema = value;
                        break;
                    }
                }

                // If no nested object found, be smarter about using response schema
                if (!resourceSchema && Object.keys(responseSchema.properties).length > 0) {
                    // Check if response only contains metadata fields
                    const metadataFields = ['message', 'error', 'errors', 'status', 'code', 'success', 'timestamp', 'meta', 'metadata'];
                    const responseKeys = Object.keys(responseSchema.properties);
                    const nonMetadataKeys = responseKeys.filter(key => !metadataFields.includes(key.toLowerCase()));

                    if (nonMetadataKeys.length === 0) {
                        // Only metadata fields, don't use response directly
                    } else if (nonMetadataKeys.length === 1) {
                        // Single non-metadata field, use it as the data source
                        const dataKey = nonMetadataKeys[0];
                        const dataSchema = responseSchema.properties[dataKey];
                        if (dataSchema.type === 'object' && dataSchema.properties) {
                            resourceSchema = dataSchema;
                        } else {
                            // Single field but not an object, use response directly but clean it
                            resourceSchema = responseSchema;
                        }
                    } else {
                        // Multiple non-metadata fields, use response directly but it will be cleaned
                        resourceSchema = responseSchema;
                    }
                }
            }

            // If response is an array, look at the items schema
            if (!resourceSchema && responseSchema.type === 'array' && responseSchema.items) {
                resourceSchema = responseSchema.items;
            }

            if (resourceSchema) {
                // Clean the schema by removing server-generated fields
                const cleanedSchema = this.cleanSchemaForRequest(resourceSchema);

                return {
                    type: 'object',
                    required: true,
                    schema: cleanedSchema,
                    description: 'Request payload (inferred from response structure)'
                };
            }

            return this.getDefaultRequestBody();
        },

        // Get default request body when inference fails
        getDefaultRequestBody() {
            return {
                type: 'object',
                required: true,
                schema: {
                    type: 'object',
                    properties: {},
                    additionalProperties: true
                },
                description: 'Request payload (using flexible schema)'
            };
        },

        // Clean schema for request by removing server-generated fields
        cleanSchemaForRequest(schema) {
            if (!schema) return schema;

            // Expanded list of server-generated fields to exclude
            const excludeFields = [
                'id',
                'created_at',
                'updated_at',

            ];

            // If schema has properties, filter them
            if (schema.properties) {
                const cleanedProperties = {};

                Object.entries(schema.properties).forEach(([key, value]) => {
                    const lowerKey = key.toLowerCase();
                    const shouldExclude = excludeFields.some(field =>
                        lowerKey === field ||
                        lowerKey === `${field}_id` ||
                        lowerKey.endsWith(`_${field}`)
                    );

                    if (!shouldExclude) {
                        cleanedProperties[key] = value;
                    }
                });

                return {
                    ...schema,
                    properties: cleanedProperties,
                    required: schema.required ? schema.required.filter(field =>
                        !excludeFields.some(exclude => field.toLowerCase() === exclude)
                    ) : []
                };
            }

            return schema;
        }
    };
{{end}}
