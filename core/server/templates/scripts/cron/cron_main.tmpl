{{define "cron_main_js"}}
<script>
/* =============================================================================
   CRON JOBS MANAGEMENT - MODULAR SYSTEM
   ============================================================================= */

// Global initialization guard
if (!window.cronSystemInitialized) {
    console.log('ðŸ”§ Initializing modular cron system...');

    /**
     * CronAPI Service Class
     * Handles all API interactions for cron job management
     */
    class CronAPI {
        constructor() {
            this.baseUrl = '/api/cron';
            this.endpoints = {
                jobs: '/jobs',
                status: '/status'
            };
        }

        /**
         * Get authentication token from localStorage
         * @returns {string|null} Auth token
         */
        getAuthToken() {
            const possibleTokenKeys = [
                '__pb_superuser_auth__'
            ];

            for (const key of possibleTokenKeys) {
                const stored = localStorage.getItem(key);
                if (stored) {
                    try {
                        const parsed = JSON.parse(stored);
                        if (parsed && parsed.token) {
                            return parsed.token;
                        }
                    } catch (e) {
                        if (stored.length > 10) {
                            return stored;
                        }
                    }
                }
            }
            return null;
        }

        /**
         * Make authenticated API request
         * @param {string} endpoint - API endpoint
         * @param {Object} options - Request options
         * @returns {Promise<Object>} API response
         */
        async makeRequest(endpoint, options = {}) {
            const token = this.getAuthToken();
            if (!token) {
                throw new Error('Authentication required');
            }

            const url = `${this.baseUrl}${endpoint}`;
            const config = {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`,
                    ...options.headers
                },
                ...options
            };

            try {
                const response = await fetch(url, config);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
                }

                return data;
            } catch (error) {
                console.error(`API request failed [${options.method || 'GET'} ${url}]:`, error);
                throw error;
            }
        }

        async getJobs(showSystemJobs = false) {
            const params = new URLSearchParams();
            if (!showSystemJobs) {
                params.append('show_system', 'false');
            }

            const endpoint = params.toString() ?
                `${this.endpoints.jobs}?${params.toString()}` :
                this.endpoints.jobs;

            return await this.makeRequest(endpoint);
        }

        async createJob(jobData) {
            return await this.makeRequest(this.endpoints.jobs, {
                method: 'POST',
                body: JSON.stringify(jobData)
            });
        }

        async updateJob(jobId, jobData) {
            return await this.makeRequest(`${this.endpoints.jobs}/${jobId}`, {
                method: 'PUT',
                body: JSON.stringify(jobData)
            });
        }

        async deleteJob(jobId) {
            return await this.makeRequest(`${this.endpoints.jobs}/${jobId}`, {
                method: 'DELETE'
            });
        }

        async runJob(jobId) {
            return await this.makeRequest(`${this.endpoints.jobs}/${jobId}/run`, {
                method: 'POST'
            });
        }

        async getStatus() {
            return await this.makeRequest(this.endpoints.status);
        }

        /**
         * Update cron system timezone
         * @param {string} timezone - New timezone
         * @returns {Promise<Object>} Update response
         */
        async updateTimezone(timezone) {
            return await this.makeRequest('/config/timezone', {
                method: 'POST',
                body: JSON.stringify({ timezone })
            });
        }


    }

    /**
     * CronUI Manager Class
     * Handles all user interface interactions for cron job management
     */
    class CronUI {
        constructor(manager = null) {
            this.manager = manager;
            this.elements = {
                // Main containers
                loading: document.getElementById('cron-loading'),
                empty: document.getElementById('cron-empty'),
                tableWrapper: document.getElementById('cron-table-wrapper'),
                tbody: document.getElementById('cron-jobs-tbody'),

                // Stats elements
                totalJobs: document.getElementById('total-jobs'),
                activeJobs: document.getElementById('active-jobs'),



                // Modals
                modal: document.getElementById('cron-modal-overlay'),
                modalTitle: document.getElementById('cron-modal-title'),
                detailsModal: document.getElementById('cron-details-overlay')
            };


            this.setupEventListeners();
        }

        setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    this.hideJobInfo();
                    this.hideDetailsModal();
                }
            });

            if (this.elements.modal) {
                this.elements.modal.addEventListener('click', (e) => {
                    if (e.target === this.elements.modal) {
                        this.hideJobModal();
                    }
                });
            }

            if (this.elements.detailsModal) {
                this.elements.detailsModal.addEventListener('click', (e) => {
                    if (e.target === this.elements.detailsModal) {
                        this.hideDetailsModal();
                    }
                });
            }

            // Info modal event listener
            const infoModal = document.getElementById('cron-info-overlay');
            if (infoModal) {
                infoModal.addEventListener('click', (e) => {
                    if (e.target === infoModal) {
                        this.hideJobInfo();
                    }
                });
            }
        }

        showLoading() {
            if (this.elements.loading) this.elements.loading.style.display = 'flex';
            if (this.elements.empty) this.elements.empty.style.display = 'none';
            if (this.elements.tableWrapper) this.elements.tableWrapper.style.display = 'none';
        }

        showEmpty() {
            if (this.elements.loading) this.elements.loading.style.display = 'none';
            if (this.elements.empty) this.elements.empty.style.display = 'block';
            if (this.elements.tableWrapper) this.elements.tableWrapper.style.display = 'none';
        }

        showTable() {
            if (this.elements.loading) this.elements.loading.style.display = 'none';
            if (this.elements.empty) this.elements.empty.style.display = 'none';
            if (this.elements.tableWrapper) this.elements.tableWrapper.style.display = 'block';
        }

        renderJobs(jobs) {
            if (!jobs || jobs.length === 0) {
                this.showEmpty();
                return;
            }

            this.showTable();

            if (this.elements.tbody) {
                this.elements.tbody.innerHTML = jobs.map(job => this.createJobRow(job)).join('');
            }
        }

        createJobRow(job) {
            const truncatedDescription = job.description ? this.truncateText(job.description, 45) : '';
            return `
                <tr class="row-handle">
                    <td class="col-type-text">
                        <div class="cron-job-name" style="margin-bottom: 4px;">${this.escapeHtml(job.name || job.id)}</div>
                        ${truncatedDescription ? `<div class="cron-job-description" title="${this.escapeHtml(job.description)}">${this.escapeHtml(truncatedDescription)}</div>` : ''}
                    </td>
                    <td class="col-type-text">
                        <span class="cron-job-type ${job.is_system_job ? 'system' : 'user'}">
                            ${job.is_system_job ? 'ðŸ”§ System' : 'ðŸ‘¤ User'}
                        </span>
                    </td>
                    <td class="col-type-text nowrap">
                        <div style="display: flex; flex-direction: column; gap: 2px;">
                            <code class="cron-expression">${this.escapeHtml(job.expression)}</code>
                            <div class="cron-description">${this.getCronDescription(job.expression)}</div>
                        </div>
                    </td>
                    <td class="col-type-action">
                        <button class="btn btn-xs btn-outline" onclick="cronManager.showJobDetails('${job.id}')" title="View Details">
                            <i class="ri-eye-line"></i>
                        </button>
                        <button class="btn btn-xs btn-success" onclick="cronManager.runJob('${job.id}')" title="Run Now">
                            <i class="ri-play-line"></i>
                        </button>
                        ${!job.is_system_job ? `
                        <button class="btn btn-xs btn-danger" onclick="cronManager.deleteJob('${job.id}')" title="Delete">
                            <i class="ri-delete-bin-line"></i>
                        </button>
                        ` : ''}
                    </td>
                </tr>
            `;
        }

        truncateText(text, maxLength) {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        updateStats(stats) {
            if (this.elements.totalJobs) {
                this.elements.totalJobs.textContent = stats.total_jobs || 0;
            }
            if (this.elements.activeJobs) {
                this.elements.activeJobs.textContent = stats.active_jobs || 0;
            }
        }

        showJobInfo() {
            const infoModal = document.getElementById('cron-info-overlay');
            if (infoModal) {
                infoModal.style.display = 'flex';
            }
        }

        hideJobInfo() {
            const infoModal = document.getElementById('cron-info-overlay');
            if (infoModal) {
                infoModal.style.display = 'none';
            }
        }



        showJobDetails(job) {
            if (!this.elements.detailsModal) return;

            const detailsContainer = document.getElementById('cron-job-details');
            if (detailsContainer) {
                detailsContainer.innerHTML = this.createJobDetailsHTML(job);
            }

            this.elements.detailsModal.style.display = 'flex';
            window.currentJobDetails = job;

            // Load job logs (use stored page or first page)
            const currentPage = window.jobLogPages && window.jobLogPages[job.id] ? window.jobLogPages[job.id] : 1;
            this.loadJobLogs(job.id, currentPage);
        }

        hideDetailsModal() {
            if (this.elements.detailsModal) {
                this.elements.detailsModal.style.display = 'none';
            }
            window.currentJobDetails = null;
        }

        createJobDetailsHTML(job) {
            return `
                <div class="cron-job-details">
                    <!-- Compact Basic Information -->
                    <div style="background: var(--baseAlt1Color); border-radius: 6px; padding: 16px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: auto 1fr auto 1fr; gap: 12px 20px; align-items: center;">
                            <strong style="color: var(--txtHintColor); font-size: 12px; text-transform: uppercase;">Name:</strong>
                            <span style="font-weight: 600;">${this.escapeHtml(job.name || job.id)}</span>

                            <strong style="color: var(--txtHintColor); font-size: 12px; text-transform: uppercase;">Type:</strong>
                            <span class="cron-job-type ${job.is_system_job ? 'system' : 'user'}">
                                ${job.is_system_job ? 'ðŸ”§ System Job' : 'ðŸ‘¤ User Job'}
                            </span>

                            <strong style="color: var(--txtHintColor); font-size: 12px; text-transform: uppercase;">Expression:</strong>
                            <code style="background: var(--baseColor); padding: 3px 6px; border-radius: 3px; font-family: var(--monospaceFontFamily);">${this.escapeHtml(job.expression)}</code>

                            <strong style="color: var(--txtHintColor); font-size: 12px; text-transform: uppercase;">Schedule:</strong>
                            <span style="color: var(--txtPrimaryColor);">${this.getCronDescription(job.expression)}</span>

                            ${job.description ? `
                            <strong style="color: var(--txtHintColor); font-size: 12px; text-transform: uppercase; grid-column: 1;">Description:</strong>
                            <span style="grid-column: 2 / -1; color: var(--txtHintColor); font-style: italic;">${this.escapeHtml(job.description)}</span>
                            ` : ''}
                        </div>
                    </div>

                    <div class="cron-job-details__section">
                        <div class="cron-job-details__section-header">
                            <i class="ri-history-line"></i>
                            <span>Execution Logs</span>
                            <button type="button" class="btn btn-xs btn-outline" onclick="refreshJobLogs('${this.escapeHtml(job.id)}')" style="margin-left: auto;">
                                <i class="ri-refresh-line"></i>
                                <span>Refresh</span>
                            </button>
                        </div>
                        <div id="job-logs-${this.escapeHtml(job.id)}" class="cron-logs">
                            <div class="cron-loading" style="padding: 2rem; text-align: center;">
                                <i class="ri-loader-4-line animate-spin"></i>
                                <span>Loading execution logs...</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        async loadJobLogs(jobId, page = 1, perPage = 20) {
            try {
                const response = await fetch(`/api/cron/logs/${jobId}?page=${page}&per_page=${perPage}`, {
                    headers: {
                        'Authorization': `Bearer ${this.manager ? this.manager.getAuthToken() : this.getAuthTokenFallback()}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                if (result.success && result.data) {
                    this.displayJobLogs(jobId, result.data.logs || [], result.data.pagination);
                } else {
                    this.displayJobLogsError(jobId, result.message || 'Failed to load logs');
                }
            } catch (error) {
                console.error('Error loading job logs:', error);
                this.displayJobLogsError(jobId, error.message);
            }
        }

        displayJobLogs(jobId, logs, pagination = null) {
            const logsContainer = document.getElementById(`job-logs-${jobId}`);
            if (!logsContainer) return;

            if (logs.length === 0) {
                logsContainer.innerHTML = `
                    <div class="cron-empty" style="padding: 2rem; text-align: center;">
                        <i class="ri-file-list-line txt-hint" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                        <p class="txt-hint">No execution logs found</p>
                        <p class="txt-hint" style="font-size: 12px;">Logs will appear here when the job runs</p>
                    </div>
                `;
                return;
            }

            const logsHTML = logs.map(log => {
                const statusClass = log.status === 'completed' ? 'success' :
                                   log.status === 'failed' ? 'error' : 'info';
                const statusIcon = log.status === 'completed' ? 'ri-check-line' :
                                   log.status === 'failed' ? 'ri-close-line' : 'ri-time-line';

                const duration = log.duration ? this.formatDuration(log.duration) : 'N/A';
                const timestamp = new Date(log.start_time).toLocaleString();
                const hasDetails = log.output || log.error;

                return `
                    <div class="cron-log-entry cron-log-entry--${statusClass} ${hasDetails ? 'has-details' : ''}" style="cursor: ${hasDetails ? 'pointer' : 'default'};">
                        <div class="cron-log-entry__timestamp">${timestamp}</div>
                        <div class="cron-log-entry__status">
                            <i class="${statusIcon}"></i>
                        </div>
                        <div class="cron-log-entry__message">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span class="cron-status cron-status--${log.status === 'completed' ? 'active' : log.status === 'failed' ? 'failed' : 'paused'}">
                                    ${log.status}
                                </span>
                                <span class="txt-hint">â€¢</span>
                                <span class="txt-hint">${duration}</span>
                                <span class="txt-hint">â€¢</span>
                                <span class="txt-hint">${log.trigger_type}</span>
                                ${hasDetails ? '<span class="txt-hint">â€¢ Click to expand</span>' : ''}
                            </div>
                            ${log.error ? `<div class="log-details txt-danger" style="font-size: 12px; margin-top: 4px; display: none;"><strong>Error:</strong><br><pre style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.2); padding: 8px; border-radius: 4px; margin-top: 4px; white-space: pre-wrap; font-size: 11px; color: var(--cron-danger); cursor: text; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text;" title="Click and drag to select text">${this.escapeHtml(log.error)}</pre></div>` : ''}
                            ${log.output ? `<div class="log-details txt-primary" style="font-size: 12px; margin-top: 4px; display: none;"><strong>Output:</strong><br><pre style="background: var(--baseAlt1Color); border: 1px solid var(--baseAlt2Color); padding: 8px; border-radius: 4px; margin-top: 4px; white-space: pre-wrap; font-size: 11px; cursor: text; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text;" title="Click and drag to select text">${this.escapeHtml(log.output)}</pre></div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            const paginationHTML = pagination ? this.createPaginationHTML(jobId, pagination) : '';

            logsContainer.innerHTML = logsHTML + paginationHTML;

            // Add click handlers for expandable log entries only
            logsContainer.querySelectorAll('.cron-log-entry.has-details').forEach(entry => {
                entry.addEventListener('click', (e) => {
                    // Don't collapse if user is selecting text
                    const selection = window.getSelection();
                    if (selection && selection.toString().length > 0) {
                        return;
                    }

                    // Don't collapse if clicking inside pre elements (output/error areas)
                    if (e.target.closest('pre')) {
                        return;
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    const isExpanded = entry.classList.contains('expanded');
                    entry.classList.toggle('expanded');

                    const details = entry.querySelectorAll('.log-details');
                    details.forEach(detail => {
                        detail.style.display = !isExpanded ? 'block' : 'none';
                    });

                    // Update the "Click to expand" text
                    const expandHint = entry.querySelector('.txt-hint:last-child');
                    if (expandHint && expandHint.textContent.includes('Click to')) {
                        expandHint.textContent = !isExpanded ? 'â€¢ Click to collapse' : 'â€¢ Click to expand';
                    }
                });
            });
        }

        displayJobLogsError(jobId, errorMessage) {
            const logsContainer = document.getElementById(`job-logs-${jobId}`);
            if (!logsContainer) return;

            logsContainer.innerHTML = `
                <div class="cron-empty" style="padding: 2rem; text-align: center;">
                    <i class="ri-error-warning-line txt-danger" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                    <p class="txt-danger">Failed to load execution logs</p>
                    <p class="txt-hint" style="font-size: 12px;">${this.escapeHtml(errorMessage)}</p>
                    <button type="button" class="btn btn-xs btn-outline" onclick="refreshJobLogs('${jobId}')" style="margin-top: 8px;">
                        <i class="ri-refresh-line"></i>
                        <span>Retry</span>
                    </button>
                </div>
            `;
        }

        refreshJobLogs(jobId, page = 1) {
            // Store current page context for this job
            if (!window.jobLogPages) {
                window.jobLogPages = {};
            }
            window.jobLogPages[jobId] = page;

            this.loadJobLogs(jobId, page);
        }

        createPaginationHTML(jobId, pagination) {
            if (!pagination || pagination.total_pages <= 1) return '';

            const currentPage = pagination.page;
            const totalPages = pagination.total_pages;

            let paginationItems = '';

            // Previous button
            if (pagination.has_prev) {
                paginationItems += `<button class="btn btn-xs btn-outline" onclick="refreshJobLogs('${jobId}', ${currentPage - 1})" style="margin-right: 4px;"><i class="ri-arrow-left-line"></i></button>`;
            }

            // Page numbers (show max 5 pages around current)
            const startPage = Math.max(1, currentPage - 2);
            const endPage = Math.min(totalPages, currentPage + 2);

            if (startPage > 1) {
                paginationItems += `<button class="btn btn-xs btn-outline" onclick="refreshJobLogs('${jobId}', 1)" style="margin-right: 2px;">1</button>`;
                if (startPage > 2) {
                    paginationItems += `<span style="margin: 0 4px;">...</span>`;
                }
            }

            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentPage;
                paginationItems += `<button class="btn btn-xs ${isActive ? 'btn-success' : 'btn-outline'}" ${isActive ? 'disabled' : `onclick="refreshJobLogs('${jobId}', ${i})"`} style="margin-right: 2px;">${i}</button>`;
            }

            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    paginationItems += `<span style="margin: 0 4px;">...</span>`;
                }
                paginationItems += `<button class="btn btn-xs btn-outline" onclick="refreshJobLogs('${jobId}', ${totalPages})" style="margin-right: 2px;">${totalPages}</button>`;
            }

            // Next button
            if (pagination.has_next) {
                paginationItems += `<button class="btn btn-xs btn-outline" onclick="refreshJobLogs('${jobId}', ${currentPage + 1})" style="margin-left: 4px;"><i class="ri-arrow-right-line"></i></button>`;
            }

            return `
                <div class="cron-logs-pagination" style="padding: 12px; border-top: 1px solid var(--baseAlt2Color); display: flex; align-items: center; justify-content: space-between; font-size: 12px;">
                    <div class="txt-hint">
                        Showing page ${currentPage} of ${totalPages} (${pagination.total} total logs)
                    </div>
                    <div>
                        ${paginationItems}
                    </div>
                </div>
            `;
        }

        getAuthTokenFallback() {
            const possibleTokenKeys = [
                '__pb_superuser_auth__'
            ];

            for (const key of possibleTokenKeys) {
                const authData = localStorage.getItem(key);
                if (authData) {
                    try {
                        const parsed = JSON.parse(authData);
                        return parsed.token;
                    } catch (e) {
                        continue;
                    }
                }
            }
            return null;
        }

        formatDuration(nanoseconds) {
            if (!nanoseconds) return 'N/A';

            const ms = Math.round(nanoseconds / 1000000);
            if (ms < 1000) return `${ms}ms`;

            const seconds = Math.round(ms / 1000 * 10) / 10;
            if (seconds < 60) return `${seconds}s`;

            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.round((seconds % 60) * 10) / 10;
            return `${minutes}m ${remainingSeconds}s`;
        }

        getCronDescription(expression) {
            // Handle macros first
            const macros = {
                '@yearly': 'Yearly (January 1st at midnight)',
                '@annually': 'Yearly (January 1st at midnight)',
                '@monthly': 'Monthly (1st day at midnight)',
                '@weekly': 'Weekly (Sunday at midnight)',
                '@daily': 'Daily at midnight',
                '@midnight': 'Daily at midnight',
                '@hourly': 'Every hour'
            };

            if (macros[expression]) {
                return macros[expression];
            }

            const parts = expression.trim().split(/\s+/);
            if (parts.length !== 5) return expression;

            try {
                const [min, hour, day, month, dow] = parts;

                // Handle common patterns first
                if (min === '*' && hour === '*' && day === '*' && month === '*' && dow === '*') {
                    return 'Every minute';
                }

                // Handle step values in minutes
                if (min.startsWith('*/') && hour === '*' && day === '*' && month === '*' && dow === '*') {
                    const step = parseInt(min.substring(2));
                    if (step === 1) return 'Every minute';
                    return `Every ${step} minutes`;
                }

                // Handle step values in hours
                if (min === '0' && hour.startsWith('*/') && day === '*' && month === '*' && dow === '*') {
                    const step = parseInt(hour.substring(2));
                    if (step === 1) return 'Every hour';
                    return `Every ${step} hours`;
                }

                // Handle daily patterns
                if (min !== '*' && hour !== '*' && day === '*' && month === '*' && dow === '*') {
                    const h = parseInt(hour);
                    const m = parseInt(min);
                    const time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                    if (h === 0 && m === 0) return 'Daily at midnight';
                    return `Daily at ${time}`;
                }

                // Handle weekly patterns
                if (min !== '*' && hour !== '*' && day === '*' && month === '*' && dow !== '*') {
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const dayName = days[parseInt(dow)] || dow;
                    const h = parseInt(hour);
                    const m = parseInt(min);
                    const time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                    if (h === 0 && m === 0) return `Weekly on ${dayName} at midnight`;
                    return `Weekly on ${dayName} at ${time}`;
                }

                // Handle hourly patterns
                if (min === '0' && hour === '*' && day === '*' && month === '*' && dow === '*') {
                    return 'Every hour';
                }

                // Handle monthly patterns
                if (min !== '*' && hour !== '*' && day !== '*' && month === '*' && dow === '*') {
                    const h = parseInt(hour);
                    const m = parseInt(min);
                    const d = parseInt(day);
                    const time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                    if (h === 0 && m === 0) return `Monthly on day ${d} at midnight`;
                    return `Monthly on day ${d} at ${time}`;
                }

                // Fallback for complex expressions
                let desc = [];

                if (min.startsWith('*/')) {
                    desc.push(`every ${min.substring(2)} min`);
                } else if (min !== '*') {
                    desc.push(`min ${min}`);
                }

                if (hour.startsWith('*/')) {
                    desc.push(`every ${hour.substring(2)}h`);
                } else if (hour !== '*') {
                    desc.push(`${hour}h`);
                }

                if (day !== '*') desc.push(`day ${day}`);
                if (month !== '*') desc.push(`month ${month}`);
                if (dow !== '*') {
                    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    desc.push(days[parseInt(dow)] || `dow ${dow}`);
                }

                return desc.length > 0 ? desc.join(', ') : 'Custom schedule';

            } catch (e) {
                return 'Custom schedule';
            }
        }





        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }



        showSuccess(message) {
            console.log('Success:', message);
            // TODO: Implement proper toast notifications
        }

        showError(message) {
            console.error('Error:', message);
            // TODO: Implement proper toast notifications
            alert('Error: ' + message); // Temporary fallback
        }
    }

    /**
     * CronManager - Main coordinator class for cron job management
     */
    class CronManager {
        constructor() {
            this.api = window.CronAPI;
            this.ui = null; // Will be set after initialization
            this.state = {
                jobs: [],
                status: 'unknown',
                config: {},
                isInitialized: false,
                pollingInterval: null,
                showSystemJobs: false
            };

            this.config = {
                pollInterval: 5000,
                retryAttempts: 3,
                retryDelay: 1000
            };
        }

        getAuthToken() {
            return this.api ? this.api.getAuthToken() : null;
        }

        async initialize() {
            if (this.state.isInitialized) {
                console.log('CronManager already initialized');
                return;
            }

            console.log('Initializing CronManager...');

            try {
                await this.loadJobs();
                this.startPolling();
                this.state.isInitialized = true;
                console.log('âœ… CronManager initialized successfully');
            } catch (error) {
                console.error('Failed to initialize CronManager:', error);
                this.ui.showError('Failed to initialize cron system: ' + error.message);
                this.state.status = 'running';
                this.startPolling();
            }
        }



        async loadJobs() {
            this.ui.showLoading();

            try {
                const showSystemJobs = this.state.showSystemJobs === true; // default to false
                const jobs = await this.api.getJobs(showSystemJobs);
                this.state.jobs = Array.isArray(jobs) ? jobs : [];

                this.ui.renderJobs(this.state.jobs);
                this.ui.updateStats({
                    total_jobs: this.state.jobs.length,
                    active_jobs: this.state.jobs.length
                });

                console.log(`Loaded ${this.state.jobs.length} cron jobs`);
            } catch (error) {
                console.error('Failed to load jobs:', error);
                this.ui.showError('Failed to load cron jobs: ' + error.message);
                this.ui.showEmpty();
            }
        }



        startPolling() {
            if (this.state.pollingInterval) {
                clearInterval(this.state.pollingInterval);
            }

            this.state.pollingInterval = setInterval(async () => {
                try {
                    // Could add job status polling here if needed
                } catch (error) {
                    console.error('Polling failed:', error);
                }
            }, this.config.pollInterval);

            console.log('Started status polling');
        }

        stopPolling() {
            if (this.state.pollingInterval) {
                clearInterval(this.state.pollingInterval);
                this.state.pollingInterval = null;
                console.log('Stopped status polling');
            }
        }

        async refresh() {
            try {
                await this.loadJobs();
                this.ui.showSuccess('Data refreshed successfully');
            } catch (error) {
                this.ui.showError('Failed to refresh data: ' + error.message);
            }
        }

        showJobInfo() {
            this.ui.showJobInfo();
        }

        async deleteJob(jobId) {
            const job = this.state.jobs.find(j => j.id === jobId);
            if (!job) {
                this.ui.showError('Job not found');
                return;
            }

            if (!confirm(`Are you sure you want to delete the job "${job.name || job.id}"?`)) {
                return;
            }

            try {
                await this.api.deleteJob(jobId);
                this.ui.showSuccess('Job deleted successfully');
                await this.loadJobs();
            } catch (error) {
                this.ui.showError('Failed to delete job: ' + error.message);
            }
        }

        async runJob(jobId) {
            const job = this.state.jobs.find(j => j.id === jobId);
            if (!job) {
                this.ui.showError('Job not found');
                return;
            }

            try {
                await this.api.runJob(jobId);
                this.ui.showSuccess(`Job "${job.name || job.id}" executed successfully`);

                // Refresh logs if job details modal is open
                if (window.currentJobDetails && window.currentJobDetails.id === jobId) {
                    // Get current page from pagination if available
                    const logsContainer = document.getElementById(`job-logs-${jobId}`);
                    let currentPage = 1;
                    if (logsContainer) {
                        const activePageBtn = logsContainer.querySelector('.btn-success[disabled]');
                        if (activePageBtn) {
                            currentPage = parseInt(activePageBtn.textContent) || 1;
                        }
                    }

                    setTimeout(() => {
                        this.ui.refreshJobLogs(jobId, currentPage);
                    }, 1000); // Wait 1 second for log to be written
                }
            } catch (error) {
                this.ui.showError('Failed to run job: ' + error.message);
            }
        }

        async showJobDetails(jobId) {
            const job = this.state.jobs.find(j => j.id === jobId);
            if (!job) {
                this.ui.showError('Job not found');
                return;
            }

            try {
                this.ui.showJobDetails(job);
            } catch (error) {
                console.error('Failed to load job details:', error);
                this.ui.showJobDetails(job);
            }
        }



        /**
         * Update system timezone
         * @param {string} timezone - New timezone
         */
        async updateTimezone(timezone) {
            try {
                await this.api.updateTimezone(timezone);
                this.ui.showSuccess('Timezone updated successfully');
            } catch (error) {
                this.ui.showError('Failed to update timezone: ' + error.message);
            }
        }

        destroy() {
            this.stopPolling();
            this.state.isInitialized = false;
            console.log('CronManager destroyed');
        }
    }

    // Initialize the system
    window.CronAPI = new CronAPI();
    window.cronManager = new CronManager();
    window.CronUI = new CronUI(window.cronManager);
    window.cronManager.ui = window.CronUI;

    // Mark as initialized to prevent double initialization
    window.cronSystemInitialized = true;

    // Verify all required components are loaded
    const requiredComponents = ['CronAPI', 'CronUI', 'cronManager'];
    const missingComponents = requiredComponents.filter(comp => !window[comp]);

    if (missingComponents.length === 0) {
        console.log('âœ… All cron components loaded successfully');
        console.log('ðŸ“Š Available components:', {
            API: typeof window.CronAPI,
            UI: typeof window.CronUI,
            Manager: typeof window.cronManager
        });

        // The cronManager will auto-initialize when DOM is ready
        // Additional setup can be done here if needed
    } else {
        console.error('âŒ Missing required cron components:', missingComponents);
    }

} else {
    console.log('âš ï¸ Cron system already initialized, skipping...');
}

/* =============================================================================
   LEGACY COMPATIBILITY FUNCTIONS
   ============================================================================= */

// These functions ensure backward compatibility with existing template calls
// They delegate to the new modular system

if (typeof window.initializeCronJobs === 'undefined') {
    window.initializeCronJobs = function() {
        return window.cronManager?.initialize();
    };
}

if (typeof window.loadCronJobs === 'undefined') {
    window.loadCronJobs = function() {
        return window.cronManager?.loadJobs();
    };
}

if (typeof window.refreshCronJobs === 'undefined') {
    window.refreshCronJobs = function() {
        if (window.cronManager) {
            return window.cronManager.loadJobs();
        }
    };
}

if (typeof window.toggleSystemJobs === 'undefined') {
    window.toggleSystemJobs = function() {
        const checkbox = document.getElementById('show-system-jobs');
        if (window.cronManager && checkbox) {
            window.cronManager.state.showSystemJobs = checkbox.checked;
            window.cronManager.loadJobs();
        }
    };
}

if (typeof window.refreshCronJobs === 'undefined') {
    window.refreshCronJobs = function() {
        return window.cronManager?.refresh();
    };
}

// Global functions for backward compatibility with existing templates
window.showCronJobInfo = () => window.cronManager.showJobInfo();
window.hideCronJobInfo = () => window.cronManager.hideJobInfo();
window.hideCronDetailsModal = () => window.cronManager.ui.hideDetailsModal();


window.updateCronTimezone = () => {
    const select = document.getElementById('cron-timezone');
    if (select) {
        window.cronManager.updateTimezone(select.value);
    }
};



window.runJobFromDetails = () => {
    if (window.currentJobDetails) {
        window.cronManager.runJob(window.currentJobDetails.id);
    }
};

window.refreshJobLogs = (jobId, page = 1) => {
    if (window.cronManager && window.cronManager.ui) {
        window.cronManager.ui.refreshJobLogs(jobId, page);
    }
};

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.cronManager.initialize();
    });
} else {
    setTimeout(() => window.cronManager.initialize(), 100);
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    window.cronManager.destroy();
});

// Export for debugging and advanced usage
window.CronSystem = {
    api: window.CronAPI,
    ui: window.CronUI,
    manager: window.cronManager,
    initialized: window.cronSystemInitialized
};

console.log('ðŸŽ‰ Modular cron system ready');
</script>
{{end}}
